; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.21005.1 

	TITLE	D:\Workspace\cocos2d-x-3.8.1\projects\mygame\libs\smartfox\ZLib\inflate.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0BH@LIBMMIGA@incorrect?5header?5check?$AA@ ; `string'
PUBLIC	??_C@_0BL@IHKGDAEE@unknown?5compression?5method?$AA@ ; `string'
PUBLIC	??_C@_0BE@EMOGCLGO@invalid?5window?5size?$AA@	; `string'
PUBLIC	??_C@_0BJ@BLBBCOMO@unknown?5header?5flags?5set?$AA@ ; `string'
PUBLIC	??_C@_0BE@GONKLEPM@header?5crc?5mismatch?$AA@	; `string'
PUBLIC	??_C@_0BF@MEIGEHBE@incorrect?5data?5check?$AA@	; `string'
PUBLIC	??_C@_0BH@FGKKJGOC@incorrect?5length?5check?$AA@ ; `string'
;	COMDAT ??_C@_0BH@FGKKJGOC@incorrect?5length?5check?$AA@
CONST	SEGMENT
??_C@_0BH@FGKKJGOC@incorrect?5length?5check?$AA@ DB 'incorrect length che'
	DB	'ck', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@MEIGEHBE@incorrect?5data?5check?$AA@
CONST	SEGMENT
??_C@_0BF@MEIGEHBE@incorrect?5data?5check?$AA@ DB 'incorrect data check', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@GONKLEPM@header?5crc?5mismatch?$AA@
CONST	SEGMENT
??_C@_0BE@GONKLEPM@header?5crc?5mismatch?$AA@ DB 'header crc mismatch', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@BLBBCOMO@unknown?5header?5flags?5set?$AA@
CONST	SEGMENT
??_C@_0BJ@BLBBCOMO@unknown?5header?5flags?5set?$AA@ DB 'unknown header fl'
	DB	'ags set', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@EMOGCLGO@invalid?5window?5size?$AA@
CONST	SEGMENT
??_C@_0BE@EMOGCLGO@invalid?5window?5size?$AA@ DB 'invalid window size', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@IHKGDAEE@unknown?5compression?5method?$AA@
CONST	SEGMENT
??_C@_0BL@IHKGDAEE@unknown?5compression?5method?$AA@ DB 'unknown compress'
	DB	'ion method', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@LIBMMIGA@incorrect?5header?5check?$AA@
CONST	SEGMENT
??_C@_0BH@LIBMMIGA@incorrect?5header?5check?$AA@ DB 'incorrect header che'
	DB	'ck', 00H					; `string'
?lenfix@?1??fixedtables@@9@9 DB 060H			; `fixedtables'::`2'::lenfix
	DB	07H
	DW	00H
	DB	00H
	DB	08H
	DW	050H
	DB	00H
	DB	08H
	DW	010H
	DB	014H
	DB	08H
	DW	073H
	DB	012H
	DB	07H
	DW	01fH
	DB	00H
	DB	08H
	DW	070H
	DB	00H
	DB	08H
	DW	030H
	DB	00H
	DB	09H
	DW	0c0H
	DB	010H
	DB	07H
	DW	0aH
	DB	00H
	DB	08H
	DW	060H
	DB	00H
	DB	08H
	DW	020H
	DB	00H
	DB	09H
	DW	0a0H
	DB	00H
	DB	08H
	DW	00H
	DB	00H
	DB	08H
	DW	080H
	DB	00H
	DB	08H
	DW	040H
	DB	00H
	DB	09H
	DW	0e0H
	DB	010H
	DB	07H
	DW	06H
	DB	00H
	DB	08H
	DW	058H
	DB	00H
	DB	08H
	DW	018H
	DB	00H
	DB	09H
	DW	090H
	DB	013H
	DB	07H
	DW	03bH
	DB	00H
	DB	08H
	DW	078H
	DB	00H
	DB	08H
	DW	038H
	DB	00H
	DB	09H
	DW	0d0H
	DB	011H
	DB	07H
	DW	011H
	DB	00H
	DB	08H
	DW	068H
	DB	00H
	DB	08H
	DW	028H
	DB	00H
	DB	09H
	DW	0b0H
	DB	00H
	DB	08H
	DW	08H
	DB	00H
	DB	08H
	DW	088H
	DB	00H
	DB	08H
	DW	048H
	DB	00H
	DB	09H
	DW	0f0H
	DB	010H
	DB	07H
	DW	04H
	DB	00H
	DB	08H
	DW	054H
	DB	00H
	DB	08H
	DW	014H
	DB	015H
	DB	08H
	DW	0e3H
	DB	013H
	DB	07H
	DW	02bH
	DB	00H
	DB	08H
	DW	074H
	DB	00H
	DB	08H
	DW	034H
	DB	00H
	DB	09H
	DW	0c8H
	DB	011H
	DB	07H
	DW	0dH
	DB	00H
	DB	08H
	DW	064H
	DB	00H
	DB	08H
	DW	024H
	DB	00H
	DB	09H
	DW	0a8H
	DB	00H
	DB	08H
	DW	04H
	DB	00H
	DB	08H
	DW	084H
	DB	00H
	DB	08H
	DW	044H
	DB	00H
	DB	09H
	DW	0e8H
	DB	010H
	DB	07H
	DW	08H
	DB	00H
	DB	08H
	DW	05cH
	DB	00H
	DB	08H
	DW	01cH
	DB	00H
	DB	09H
	DW	098H
	DB	014H
	DB	07H
	DW	053H
	DB	00H
	DB	08H
	DW	07cH
	DB	00H
	DB	08H
	DW	03cH
	DB	00H
	DB	09H
	DW	0d8H
	DB	012H
	DB	07H
	DW	017H
	DB	00H
	DB	08H
	DW	06cH
	DB	00H
	DB	08H
	DW	02cH
	DB	00H
	DB	09H
	DW	0b8H
	DB	00H
	DB	08H
	DW	0cH
	DB	00H
	DB	08H
	DW	08cH
	DB	00H
	DB	08H
	DW	04cH
	DB	00H
	DB	09H
	DW	0f8H
	DB	010H
	DB	07H
	DW	03H
	DB	00H
	DB	08H
	DW	052H
	DB	00H
	DB	08H
	DW	012H
	DB	015H
	DB	08H
	DW	0a3H
	DB	013H
	DB	07H
	DW	023H
	DB	00H
	DB	08H
	DW	072H
	DB	00H
	DB	08H
	DW	032H
	DB	00H
	DB	09H
	DW	0c4H
	DB	011H
	DB	07H
	DW	0bH
	DB	00H
	DB	08H
	DW	062H
	DB	00H
	DB	08H
	DW	022H
	DB	00H
	DB	09H
	DW	0a4H
	DB	00H
	DB	08H
	DW	02H
	DB	00H
	DB	08H
	DW	082H
	DB	00H
	DB	08H
	DW	042H
	DB	00H
	DB	09H
	DW	0e4H
	DB	010H
	DB	07H
	DW	07H
	DB	00H
	DB	08H
	DW	05aH
	DB	00H
	DB	08H
	DW	01aH
	DB	00H
	DB	09H
	DW	094H
	DB	014H
	DB	07H
	DW	043H
	DB	00H
	DB	08H
	DW	07aH
	DB	00H
	DB	08H
	DW	03aH
	DB	00H
	DB	09H
	DW	0d4H
	DB	012H
	DB	07H
	DW	013H
	DB	00H
	DB	08H
	DW	06aH
	DB	00H
	DB	08H
	DW	02aH
	DB	00H
	DB	09H
	DW	0b4H
	DB	00H
	DB	08H
	DW	0aH
	DB	00H
	DB	08H
	DW	08aH
	DB	00H
	DB	08H
	DW	04aH
	DB	00H
	DB	09H
	DW	0f4H
	DB	010H
	DB	07H
	DW	05H
	DB	00H
	DB	08H
	DW	056H
	DB	00H
	DB	08H
	DW	016H
	DB	040H
	DB	08H
	DW	00H
	DB	013H
	DB	07H
	DW	033H
	DB	00H
	DB	08H
	DW	076H
	DB	00H
	DB	08H
	DW	036H
	DB	00H
	DB	09H
	DW	0ccH
	DB	011H
	DB	07H
	DW	0fH
	DB	00H
	DB	08H
	DW	066H
	DB	00H
	DB	08H
	DW	026H
	DB	00H
	DB	09H
	DW	0acH
	DB	00H
	DB	08H
	DW	06H
	DB	00H
	DB	08H
	DW	086H
	DB	00H
	DB	08H
	DW	046H
	DB	00H
	DB	09H
	DW	0ecH
	DB	010H
	DB	07H
	DW	09H
	DB	00H
	DB	08H
	DW	05eH
	DB	00H
	DB	08H
	DW	01eH
	DB	00H
	DB	09H
	DW	09cH
	DB	014H
	DB	07H
	DW	063H
	DB	00H
	DB	08H
	DW	07eH
	DB	00H
	DB	08H
	DW	03eH
	DB	00H
	DB	09H
	DW	0dcH
	DB	012H
	DB	07H
	DW	01bH
	DB	00H
	DB	08H
	DW	06eH
	DB	00H
	DB	08H
	DW	02eH
	DB	00H
	DB	09H
	DW	0bcH
	DB	00H
	DB	08H
	DW	0eH
	DB	00H
	DB	08H
	DW	08eH
	DB	00H
	DB	08H
	DW	04eH
	DB	00H
	DB	09H
	DW	0fcH
	DB	060H
	DB	07H
	DW	00H
	DB	00H
	DB	08H
	DW	051H
	DB	00H
	DB	08H
	DW	011H
	DB	015H
	DB	08H
	DW	083H
	DB	012H
	DB	07H
	DW	01fH
	DB	00H
	DB	08H
	DW	071H
	DB	00H
	DB	08H
	DW	031H
	DB	00H
	DB	09H
	DW	0c2H
	DB	010H
	DB	07H
	DW	0aH
	DB	00H
	DB	08H
	DW	061H
	DB	00H
	DB	08H
	DW	021H
	DB	00H
	DB	09H
	DW	0a2H
	DB	00H
	DB	08H
	DW	01H
	DB	00H
	DB	08H
	DW	081H
	DB	00H
	DB	08H
	DW	041H
	DB	00H
	DB	09H
	DW	0e2H
	DB	010H
	DB	07H
	DW	06H
	DB	00H
	DB	08H
	DW	059H
	DB	00H
	DB	08H
	DW	019H
	DB	00H
	DB	09H
	DW	092H
	DB	013H
	DB	07H
	DW	03bH
	DB	00H
	DB	08H
	DW	079H
	DB	00H
	DB	08H
	DW	039H
	DB	00H
	DB	09H
	DW	0d2H
	DB	011H
	DB	07H
	DW	011H
	DB	00H
	DB	08H
	DW	069H
	DB	00H
	DB	08H
	DW	029H
	DB	00H
	DB	09H
	DW	0b2H
	DB	00H
	DB	08H
	DW	09H
	DB	00H
	DB	08H
	DW	089H
	DB	00H
	DB	08H
	DW	049H
	DB	00H
	DB	09H
	DW	0f2H
	DB	010H
	DB	07H
	DW	04H
	DB	00H
	DB	08H
	DW	055H
	DB	00H
	DB	08H
	DW	015H
	DB	010H
	DB	08H
	DW	0102H
	DB	013H
	DB	07H
	DW	02bH
	DB	00H
	DB	08H
	DW	075H
	DB	00H
	DB	08H
	DW	035H
	DB	00H
	DB	09H
	DW	0caH
	DB	011H
	DB	07H
	DW	0dH
	DB	00H
	DB	08H
	DW	065H
	DB	00H
	DB	08H
	DW	025H
	DB	00H
	DB	09H
	DW	0aaH
	DB	00H
	DB	08H
	DW	05H
	DB	00H
	DB	08H
	DW	085H
	DB	00H
	DB	08H
	DW	045H
	DB	00H
	DB	09H
	DW	0eaH
	DB	010H
	DB	07H
	DW	08H
	DB	00H
	DB	08H
	DW	05dH
	DB	00H
	DB	08H
	DW	01dH
	DB	00H
	DB	09H
	DW	09aH
	DB	014H
	DB	07H
	DW	053H
	DB	00H
	DB	08H
	DW	07dH
	DB	00H
	DB	08H
	DW	03dH
	DB	00H
	DB	09H
	DW	0daH
	DB	012H
	DB	07H
	DW	017H
	DB	00H
	DB	08H
	DW	06dH
	DB	00H
	DB	08H
	DW	02dH
	DB	00H
	DB	09H
	DW	0baH
	DB	00H
	DB	08H
	DW	0dH
	DB	00H
	DB	08H
	DW	08dH
	DB	00H
	DB	08H
	DW	04dH
	DB	00H
	DB	09H
	DW	0faH
	DB	010H
	DB	07H
	DW	03H
	DB	00H
	DB	08H
	DW	053H
	DB	00H
	DB	08H
	DW	013H
	DB	015H
	DB	08H
	DW	0c3H
	DB	013H
	DB	07H
	DW	023H
	DB	00H
	DB	08H
	DW	073H
	DB	00H
	DB	08H
	DW	033H
	DB	00H
	DB	09H
	DW	0c6H
	DB	011H
	DB	07H
	DW	0bH
	DB	00H
	DB	08H
	DW	063H
	DB	00H
	DB	08H
	DW	023H
	DB	00H
	DB	09H
	DW	0a6H
	DB	00H
	DB	08H
	DW	03H
	DB	00H
	DB	08H
	DW	083H
	DB	00H
	DB	08H
	DW	043H
	DB	00H
	DB	09H
	DW	0e6H
	DB	010H
	DB	07H
	DW	07H
	DB	00H
	DB	08H
	DW	05bH
	DB	00H
	DB	08H
	DW	01bH
	DB	00H
	DB	09H
	DW	096H
	DB	014H
	DB	07H
	DW	043H
	DB	00H
	DB	08H
	DW	07bH
	DB	00H
	DB	08H
	DW	03bH
	DB	00H
	DB	09H
	DW	0d6H
	DB	012H
	DB	07H
	DW	013H
	DB	00H
	DB	08H
	DW	06bH
	DB	00H
	DB	08H
	DW	02bH
	DB	00H
	DB	09H
	DW	0b6H
	DB	00H
	DB	08H
	DW	0bH
	DB	00H
	DB	08H
	DW	08bH
	DB	00H
	DB	08H
	DW	04bH
	DB	00H
	DB	09H
	DW	0f6H
	DB	010H
	DB	07H
	DW	05H
	DB	00H
	DB	08H
	DW	057H
	DB	00H
	DB	08H
	DW	017H
	DB	040H
	DB	08H
	DW	00H
	DB	013H
	DB	07H
	DW	033H
	DB	00H
	DB	08H
	DW	077H
	DB	00H
	DB	08H
	DW	037H
	DB	00H
	DB	09H
	DW	0ceH
	DB	011H
	DB	07H
	DW	0fH
	DB	00H
	DB	08H
	DW	067H
	DB	00H
	DB	08H
	DW	027H
	DB	00H
	DB	09H
	DW	0aeH
	DB	00H
	DB	08H
	DW	07H
	DB	00H
	DB	08H
	DW	087H
	DB	00H
	DB	08H
	DW	047H
	DB	00H
	DB	09H
	DW	0eeH
	DB	010H
	DB	07H
	DW	09H
	DB	00H
	DB	08H
	DW	05fH
	DB	00H
	DB	08H
	DW	01fH
	DB	00H
	DB	09H
	DW	09eH
	DB	014H
	DB	07H
	DW	063H
	DB	00H
	DB	08H
	DW	07fH
	DB	00H
	DB	08H
	DW	03fH
	DB	00H
	DB	09H
	DW	0deH
	DB	012H
	DB	07H
	DW	01bH
	DB	00H
	DB	08H
	DW	06fH
	DB	00H
	DB	08H
	DW	02fH
	DB	00H
	DB	09H
	DW	0beH
	DB	00H
	DB	08H
	DW	0fH
	DB	00H
	DB	08H
	DW	08fH
	DB	00H
	DB	08H
	DW	04fH
	DB	00H
	DB	09H
	DW	0feH
	DB	060H
	DB	07H
	DW	00H
	DB	00H
	DB	08H
	DW	050H
	DB	00H
	DB	08H
	DW	010H
	DB	014H
	DB	08H
	DW	073H
	DB	012H
	DB	07H
	DW	01fH
	DB	00H
	DB	08H
	DW	070H
	DB	00H
	DB	08H
	DW	030H
	DB	00H
	DB	09H
	DW	0c1H
	DB	010H
	DB	07H
	DW	0aH
	DB	00H
	DB	08H
	DW	060H
	DB	00H
	DB	08H
	DW	020H
	DB	00H
	DB	09H
	DW	0a1H
	DB	00H
	DB	08H
	DW	00H
	DB	00H
	DB	08H
	DW	080H
	DB	00H
	DB	08H
	DW	040H
	DB	00H
	DB	09H
	DW	0e1H
	DB	010H
	DB	07H
	DW	06H
	DB	00H
	DB	08H
	DW	058H
	DB	00H
	DB	08H
	DW	018H
	DB	00H
	DB	09H
	DW	091H
	DB	013H
	DB	07H
	DW	03bH
	DB	00H
	DB	08H
	DW	078H
	DB	00H
	DB	08H
	DW	038H
	DB	00H
	DB	09H
	DW	0d1H
	DB	011H
	DB	07H
	DW	011H
	DB	00H
	DB	08H
	DW	068H
	DB	00H
	DB	08H
	DW	028H
	DB	00H
	DB	09H
	DW	0b1H
	DB	00H
	DB	08H
	DW	08H
	DB	00H
	DB	08H
	DW	088H
	DB	00H
	DB	08H
	DW	048H
	DB	00H
	DB	09H
	DW	0f1H
	DB	010H
	DB	07H
	DW	04H
	DB	00H
	DB	08H
	DW	054H
	DB	00H
	DB	08H
	DW	014H
	DB	015H
	DB	08H
	DW	0e3H
	DB	013H
	DB	07H
	DW	02bH
	DB	00H
	DB	08H
	DW	074H
	DB	00H
	DB	08H
	DW	034H
	DB	00H
	DB	09H
	DW	0c9H
	DB	011H
	DB	07H
	DW	0dH
	DB	00H
	DB	08H
	DW	064H
	DB	00H
	DB	08H
	DW	024H
	DB	00H
	DB	09H
	DW	0a9H
	DB	00H
	DB	08H
	DW	04H
	DB	00H
	DB	08H
	DW	084H
	DB	00H
	DB	08H
	DW	044H
	DB	00H
	DB	09H
	DW	0e9H
	DB	010H
	DB	07H
	DW	08H
	DB	00H
	DB	08H
	DW	05cH
	DB	00H
	DB	08H
	DW	01cH
	DB	00H
	DB	09H
	DW	099H
	DB	014H
	DB	07H
	DW	053H
	DB	00H
	DB	08H
	DW	07cH
	DB	00H
	DB	08H
	DW	03cH
	DB	00H
	DB	09H
	DW	0d9H
	DB	012H
	DB	07H
	DW	017H
	DB	00H
	DB	08H
	DW	06cH
	DB	00H
	DB	08H
	DW	02cH
	DB	00H
	DB	09H
	DW	0b9H
	DB	00H
	DB	08H
	DW	0cH
	DB	00H
	DB	08H
	DW	08cH
	DB	00H
	DB	08H
	DW	04cH
	DB	00H
	DB	09H
	DW	0f9H
	DB	010H
	DB	07H
	DW	03H
	DB	00H
	DB	08H
	DW	052H
	DB	00H
	DB	08H
	DW	012H
	DB	015H
	DB	08H
	DW	0a3H
	DB	013H
	DB	07H
	DW	023H
	DB	00H
	DB	08H
	DW	072H
	DB	00H
	DB	08H
	DW	032H
	DB	00H
	DB	09H
	DW	0c5H
	DB	011H
	DB	07H
	DW	0bH
	DB	00H
	DB	08H
	DW	062H
	DB	00H
	DB	08H
	DW	022H
	DB	00H
	DB	09H
	DW	0a5H
	DB	00H
	DB	08H
	DW	02H
	DB	00H
	DB	08H
	DW	082H
	DB	00H
	DB	08H
	DW	042H
	DB	00H
	DB	09H
	DW	0e5H
	DB	010H
	DB	07H
	DW	07H
	DB	00H
	DB	08H
	DW	05aH
	DB	00H
	DB	08H
	DW	01aH
	DB	00H
	DB	09H
	DW	095H
	DB	014H
	DB	07H
	DW	043H
	DB	00H
	DB	08H
	DW	07aH
	DB	00H
	DB	08H
	DW	03aH
	DB	00H
	DB	09H
	DW	0d5H
	DB	012H
	DB	07H
	DW	013H
	DB	00H
	DB	08H
	DW	06aH
	DB	00H
	DB	08H
	DW	02aH
	DB	00H
	DB	09H
	DW	0b5H
	DB	00H
	DB	08H
	DW	0aH
	DB	00H
	DB	08H
	DW	08aH
	DB	00H
	DB	08H
	DW	04aH
	DB	00H
	DB	09H
	DW	0f5H
	DB	010H
	DB	07H
	DW	05H
	DB	00H
	DB	08H
	DW	056H
	DB	00H
	DB	08H
	DW	016H
	DB	040H
	DB	08H
	DW	00H
	DB	013H
	DB	07H
	DW	033H
	DB	00H
	DB	08H
	DW	076H
	DB	00H
	DB	08H
	DW	036H
	DB	00H
	DB	09H
	DW	0cdH
	DB	011H
	DB	07H
	DW	0fH
	DB	00H
	DB	08H
	DW	066H
	DB	00H
	DB	08H
	DW	026H
	DB	00H
	DB	09H
	DW	0adH
	DB	00H
	DB	08H
	DW	06H
	DB	00H
	DB	08H
	DW	086H
	DB	00H
	DB	08H
	DW	046H
	DB	00H
	DB	09H
	DW	0edH
	DB	010H
	DB	07H
	DW	09H
	DB	00H
	DB	08H
	DW	05eH
	DB	00H
	DB	08H
	DW	01eH
	DB	00H
	DB	09H
	DW	09dH
	DB	014H
	DB	07H
	DW	063H
	DB	00H
	DB	08H
	DW	07eH
	DB	00H
	DB	08H
	DW	03eH
	DB	00H
	DB	09H
	DW	0ddH
	DB	012H
	DB	07H
	DW	01bH
	DB	00H
	DB	08H
	DW	06eH
	DB	00H
	DB	08H
	DW	02eH
	DB	00H
	DB	09H
	DW	0bdH
	DB	00H
	DB	08H
	DW	0eH
	DB	00H
	DB	08H
	DW	08eH
	DB	00H
	DB	08H
	DW	04eH
	DB	00H
	DB	09H
	DW	0fdH
	DB	060H
	DB	07H
	DW	00H
	DB	00H
	DB	08H
	DW	051H
	DB	00H
	DB	08H
	DW	011H
	DB	015H
	DB	08H
	DW	083H
	DB	012H
	DB	07H
	DW	01fH
	DB	00H
	DB	08H
	DW	071H
	DB	00H
	DB	08H
	DW	031H
	DB	00H
	DB	09H
	DW	0c3H
	DB	010H
	DB	07H
	DW	0aH
	DB	00H
	DB	08H
	DW	061H
	DB	00H
	DB	08H
	DW	021H
	DB	00H
	DB	09H
	DW	0a3H
	DB	00H
	DB	08H
	DW	01H
	DB	00H
	DB	08H
	DW	081H
	DB	00H
	DB	08H
	DW	041H
	DB	00H
	DB	09H
	DW	0e3H
	DB	010H
	DB	07H
	DW	06H
	DB	00H
	DB	08H
	DW	059H
	DB	00H
	DB	08H
	DW	019H
	DB	00H
	DB	09H
	DW	093H
	DB	013H
	DB	07H
	DW	03bH
	DB	00H
	DB	08H
	DW	079H
	DB	00H
	DB	08H
	DW	039H
	DB	00H
	DB	09H
	DW	0d3H
	DB	011H
	DB	07H
	DW	011H
	DB	00H
	DB	08H
	DW	069H
	DB	00H
	DB	08H
	DW	029H
	DB	00H
	DB	09H
	DW	0b3H
	DB	00H
	DB	08H
	DW	09H
	DB	00H
	DB	08H
	DW	089H
	DB	00H
	DB	08H
	DW	049H
	DB	00H
	DB	09H
	DW	0f3H
	DB	010H
	DB	07H
	DW	04H
	DB	00H
	DB	08H
	DW	055H
	DB	00H
	DB	08H
	DW	015H
	DB	010H
	DB	08H
	DW	0102H
	DB	013H
	DB	07H
	DW	02bH
	DB	00H
	DB	08H
	DW	075H
	DB	00H
	DB	08H
	DW	035H
	DB	00H
	DB	09H
	DW	0cbH
	DB	011H
	DB	07H
	DW	0dH
	DB	00H
	DB	08H
	DW	065H
	DB	00H
	DB	08H
	DW	025H
	DB	00H
	DB	09H
	DW	0abH
	DB	00H
	DB	08H
	DW	05H
	DB	00H
	DB	08H
	DW	085H
	DB	00H
	DB	08H
	DW	045H
	DB	00H
	DB	09H
	DW	0ebH
	DB	010H
	DB	07H
	DW	08H
	DB	00H
	DB	08H
	DW	05dH
	DB	00H
	DB	08H
	DW	01dH
	DB	00H
	DB	09H
	DW	09bH
	DB	014H
	DB	07H
	DW	053H
	DB	00H
	DB	08H
	DW	07dH
	DB	00H
	DB	08H
	DW	03dH
	DB	00H
	DB	09H
	DW	0dbH
	DB	012H
	DB	07H
	DW	017H
	DB	00H
	DB	08H
	DW	06dH
	DB	00H
	DB	08H
	DW	02dH
	DB	00H
	DB	09H
	DW	0bbH
	DB	00H
	DB	08H
	DW	0dH
	DB	00H
	DB	08H
	DW	08dH
	DB	00H
	DB	08H
	DW	04dH
	DB	00H
	DB	09H
	DW	0fbH
	DB	010H
	DB	07H
	DW	03H
	DB	00H
	DB	08H
	DW	053H
	DB	00H
	DB	08H
	DW	013H
	DB	015H
	DB	08H
	DW	0c3H
	DB	013H
	DB	07H
	DW	023H
	DB	00H
	DB	08H
	DW	073H
	DB	00H
	DB	08H
	DW	033H
	DB	00H
	DB	09H
	DW	0c7H
	DB	011H
	DB	07H
	DW	0bH
	DB	00H
	DB	08H
	DW	063H
	DB	00H
	DB	08H
	DW	023H
	DB	00H
	DB	09H
	DW	0a7H
	DB	00H
	DB	08H
	DW	03H
	DB	00H
	DB	08H
	DW	083H
	DB	00H
	DB	08H
	DW	043H
	DB	00H
	DB	09H
	DW	0e7H
	DB	010H
	DB	07H
	DW	07H
	DB	00H
	DB	08H
	DW	05bH
	DB	00H
	DB	08H
	DW	01bH
	DB	00H
	DB	09H
	DW	097H
	DB	014H
	DB	07H
	DW	043H
	DB	00H
	DB	08H
	DW	07bH
	DB	00H
	DB	08H
	DW	03bH
	DB	00H
	DB	09H
	DW	0d7H
	DB	012H
	DB	07H
	DW	013H
	DB	00H
	DB	08H
	DW	06bH
	DB	00H
	DB	08H
	DW	02bH
	DB	00H
	DB	09H
	DW	0b7H
	DB	00H
	DB	08H
	DW	0bH
	DB	00H
	DB	08H
	DW	08bH
	DB	00H
	DB	08H
	DW	04bH
	DB	00H
	DB	09H
	DW	0f7H
	DB	010H
	DB	07H
	DW	05H
	DB	00H
	DB	08H
	DW	057H
	DB	00H
	DB	08H
	DW	017H
	DB	040H
	DB	08H
	DW	00H
	DB	013H
	DB	07H
	DW	033H
	DB	00H
	DB	08H
	DW	077H
	DB	00H
	DB	08H
	DW	037H
	DB	00H
	DB	09H
	DW	0cfH
	DB	011H
	DB	07H
	DW	0fH
	DB	00H
	DB	08H
	DW	067H
	DB	00H
	DB	08H
	DW	027H
	DB	00H
	DB	09H
	DW	0afH
	DB	00H
	DB	08H
	DW	07H
	DB	00H
	DB	08H
	DW	087H
	DB	00H
	DB	08H
	DW	047H
	DB	00H
	DB	09H
	DW	0efH
	DB	010H
	DB	07H
	DW	09H
	DB	00H
	DB	08H
	DW	05fH
	DB	00H
	DB	08H
	DW	01fH
	DB	00H
	DB	09H
	DW	09fH
	DB	014H
	DB	07H
	DW	063H
	DB	00H
	DB	08H
	DW	07fH
	DB	00H
	DB	08H
	DW	03fH
	DB	00H
	DB	09H
	DW	0dfH
	DB	012H
	DB	07H
	DW	01bH
	DB	00H
	DB	08H
	DW	06fH
	DB	00H
	DB	08H
	DW	02fH
	DB	00H
	DB	09H
	DW	0bfH
	DB	00H
	DB	08H
	DW	0fH
	DB	00H
	DB	08H
	DW	08fH
	DB	00H
	DB	08H
	DW	04fH
	DB	00H
	DB	09H
	DW	0ffH
	ORG $+8
?order@?1??inflate@@9@9 DW 010H				; `inflate'::`2'::order
	DW	011H
	DW	012H
	DW	00H
	DW	08H
	DW	07H
	DW	09H
	DW	06H
	DW	0aH
	DW	05H
	DW	0bH
	DW	04H
	DW	0cH
	DW	03H
	DW	0dH
	DW	02H
	DW	0eH
	DW	01H
	DW	0fH
	ORG $+2
?distfix@?1??fixedtables@@9@9 DB 010H			; `fixedtables'::`2'::distfix
	DB	05H
	DW	01H
	DB	017H
	DB	05H
	DW	0101H
	DB	013H
	DB	05H
	DW	011H
	DB	01bH
	DB	05H
	DW	01001H
	DB	011H
	DB	05H
	DW	05H
	DB	019H
	DB	05H
	DW	0401H
	DB	015H
	DB	05H
	DW	041H
	DB	01dH
	DB	05H
	DW	04001H
	DB	010H
	DB	05H
	DW	03H
	DB	018H
	DB	05H
	DW	0201H
	DB	014H
	DB	05H
	DW	021H
	DB	01cH
	DB	05H
	DW	02001H
	DB	012H
	DB	05H
	DW	09H
	DB	01aH
	DB	05H
	DW	0801H
	DB	016H
	DB	05H
	DW	081H
	DB	040H
	DB	05H
	DW	00H
	DB	010H
	DB	05H
	DW	02H
	DB	017H
	DB	05H
	DW	0181H
	DB	013H
	DB	05H
	DW	019H
	DB	01bH
	DB	05H
	DW	01801H
	DB	011H
	DB	05H
	DW	07H
	DB	019H
	DB	05H
	DW	0601H
	DB	015H
	DB	05H
	DW	061H
	DB	01dH
	DB	05H
	DW	06001H
	DB	010H
	DB	05H
	DW	04H
	DB	018H
	DB	05H
	DW	0301H
	DB	014H
	DB	05H
	DW	031H
	DB	01cH
	DB	05H
	DW	03001H
	DB	012H
	DB	05H
	DW	0dH
	DB	01aH
	DB	05H
	DW	0c01H
	DB	016H
	DB	05H
	DW	0c1H
	DB	040H
	DB	05H
	DW	00H
PUBLIC	_inflateMark@4
PUBLIC	_inflateUndermine@8
PUBLIC	_inflateCopy@8
PUBLIC	_inflateSyncPoint@4
PUBLIC	_inflateSync@4
PUBLIC	_inflateGetHeader@8
PUBLIC	_inflateSetDictionary@12
PUBLIC	_inflatePrime@12
PUBLIC	_inflateInit_@12
PUBLIC	_inflateReset2@8
PUBLIC	_inflateResetKeep@4
PUBLIC	_inflateInit2_@16
PUBLIC	_inflateReset@4
PUBLIC	_inflate@8
PUBLIC	_inflateEnd@4
; Function compile flags: /Ogtp
; File d:\workspace\cocos2d-x-3.8.1\projects\mygame\libs\smartfox\zlib\inflate.c
;	COMDAT _inflateEnd@4
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_inflateEnd@4 PROC					; COMDAT

; 1255 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 1256 :     struct inflate_state FAR *state;
; 1257 :     if (strm == Z_NULL || strm->state == Z_NULL || strm->zfree == (free_func)0)

  00004	8b 75 08	 mov	 esi, DWORD PTR _strm$[ebp]
  00007	85 f6		 test	 esi, esi
  00009	74 3a		 je	 SHORT $LN2@inflateEnd
  0000b	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  0000e	85 c0		 test	 eax, eax
  00010	74 33		 je	 SHORT $LN2@inflateEnd
  00012	8b 4e 24	 mov	 ecx, DWORD PTR [esi+36]
  00015	85 c9		 test	 ecx, ecx
  00017	74 2c		 je	 SHORT $LN2@inflateEnd

; 1259 :     state = (struct inflate_state FAR *)strm->state;
; 1260 :     if (state->window != Z_NULL) ZFREE(strm, state->window);

  00019	8b 40 34	 mov	 eax, DWORD PTR [eax+52]
  0001c	85 c0		 test	 eax, eax
  0001e	74 09		 je	 SHORT $LN1@inflateEnd
  00020	50		 push	 eax
  00021	ff 76 28	 push	 DWORD PTR [esi+40]
  00024	ff d1		 call	 ecx
  00026	83 c4 08	 add	 esp, 8
$LN1@inflateEnd:

; 1261 :     ZFREE(strm, strm->state);

  00029	ff 76 1c	 push	 DWORD PTR [esi+28]
  0002c	8b 46 24	 mov	 eax, DWORD PTR [esi+36]
  0002f	ff 76 28	 push	 DWORD PTR [esi+40]
  00032	ff d0		 call	 eax
  00034	83 c4 08	 add	 esp, 8

; 1262 :     strm->state = Z_NULL;

  00037	c7 46 1c 00 00
	00 00		 mov	 DWORD PTR [esi+28], 0

; 1263 :     Tracev((stderr, "inflate: end\n"));
; 1264 :     return Z_OK;

  0003e	33 c0		 xor	 eax, eax
  00040	5e		 pop	 esi

; 1265 : }

  00041	5d		 pop	 ebp
  00042	c2 04 00	 ret	 4
$LN2@inflateEnd:

; 1258 :         return Z_STREAM_ERROR;

  00045	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  0004a	5e		 pop	 esi

; 1265 : }

  0004b	5d		 pop	 ebp
  0004c	c2 04 00	 ret	 4
_inflateEnd@4 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\workspace\cocos2d-x-3.8.1\projects\mygame\libs\smartfox\zlib\inflate.c
;	COMDAT _inflate@8
_TEXT	SEGMENT
tv2749 = -64						; size = 4
_in$1$ = -60						; size = 4
$T1 = -56						; size = 4
_copy$9$ = -56						; size = 4
tv2730 = -56						; size = 4
tv2689 = -56						; size = 4
tv2688 = -56						; size = 4
tv2676 = -56						; size = 4
tv2662 = -56						; size = 4
tv2639 = -56						; size = 4
tv2638 = -56						; size = 4
tv2595 = -56						; size = 4
_copy$7$ = -56						; size = 4
_copy$4$ = -56						; size = 4
_copy$3$ = -56						; size = 4
_copy$2$ = -56						; size = 4
_len$5$ = -56						; size = 4
_len$1$ = -56						; size = 4
_last$ = -56						; size = 4
_here$ = -56						; size = 4
_copy$11$ = -52						; size = 4
_copy$8$ = -52						; size = 4
tv2683 = -52						; size = 4
tv2682 = -52						; size = 4
tv2660 = -52						; size = 4
tv2636 = -52						; size = 4
_copy$1$ = -52						; size = 4
tv2752 = -48						; size = 4
_ret$1$ = -44						; size = 4
_from$1$ = -40						; size = 4
tv2758 = -40						; size = 4
tv2668 = -40						; size = 4
tv2659 = -40						; size = 4
tv2658 = -40						; size = 4
_len$4$ = -40						; size = 4
_len$3$ = -40						; size = 4
_len$2$ = -40						; size = 4
_out$1$ = -36						; size = 4
_put$1$ = -32						; size = 4
_hbuf$ = -28						; size = 4
_left$1$ = -24						; size = 4
tv2650 = -20						; size = 4
tv2649 = -20						; size = 4
_bits$1$ = -20						; size = 4
_next$1$ = -16						; size = 4
tv2686 = -12						; size = 4
_have$1$ = -12						; size = 4
_state$1$ = -8						; size = 4
_hold$1$ = -4						; size = 4
tv2620 = 8						; size = 4
_strm$ = 8						; size = 4
_flush$ = 12						; size = 4
_inflate@8 PROC						; COMDAT

; 607  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 608  :     struct inflate_state FAR *state;
; 609  :     unsigned char FAR *next;    /* next input */
; 610  :     unsigned char FAR *put;     /* next output */
; 611  :     unsigned have, left;        /* available input and output */
; 612  :     unsigned long hold;         /* bit buffer */
; 613  :     unsigned bits;              /* bits in bit buffer */
; 614  :     unsigned in, out;           /* save starting available input and output */
; 615  :     unsigned copy;              /* number of stored or match bytes to copy */
; 616  :     unsigned char FAR *from;    /* where to copy match bytes from */
; 617  :     code here;                  /* current decoding table entry */
; 618  :     code last;                  /* parent table entry */
; 619  :     unsigned len;               /* length to copy for repeats, bits to drop */
; 620  :     int ret;                    /* return code */
; 621  : #ifdef GUNZIP
; 622  :     unsigned char hbuf[4];      /* buffer for gzip header crc calculation */
; 623  : #endif
; 624  :     static const unsigned short order[19] = /* permutation of code lengths */
; 625  :         {16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15};
; 626  : 
; 627  :     if (strm == Z_NULL || strm->state == Z_NULL || strm->next_out == Z_NULL ||
; 628  :         (strm->next_in == Z_NULL && strm->avail_in != 0))

  00003	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00006	83 ec 40	 sub	 esp, 64			; 00000040H
  00009	85 c0		 test	 eax, eax
  0000b	0f 84 0e 16 00
	00		 je	 $LN498@inflate
  00011	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  00014	89 4d f8	 mov	 DWORD PTR _state$1$[ebp], ecx
  00017	85 c9		 test	 ecx, ecx
  00019	0f 84 00 16 00
	00		 je	 $LN498@inflate
  0001f	83 78 0c 00	 cmp	 DWORD PTR [eax+12], 0
  00023	0f 84 f6 15 00
	00		 je	 $LN498@inflate
  00029	83 38 00	 cmp	 DWORD PTR [eax], 0
  0002c	75 0a		 jne	 SHORT $LN499@inflate
  0002e	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00032	0f 85 e7 15 00
	00		 jne	 $LN498@inflate
$LN499@inflate:

; 630  : 
; 631  :     state = (struct inflate_state FAR *)strm->state;
; 632  :     if (state->mode == TYPE) state->mode = TYPEDO;      /* skip check */

  00038	83 39 0b	 cmp	 DWORD PTR [ecx], 11	; 0000000bH
  0003b	75 06		 jne	 SHORT $LN496@inflate
  0003d	c7 01 0c 00 00
	00		 mov	 DWORD PTR [ecx], 12	; 0000000cH
$LN496@inflate:

; 633  :     LOAD();

  00043	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  00046	53		 push	 ebx
  00047	8b 58 04	 mov	 ebx, DWORD PTR [eax+4]
  0004a	56		 push	 esi
  0004b	8b 71 3c	 mov	 esi, DWORD PTR [ecx+60]
  0004e	89 55 e0	 mov	 DWORD PTR _put$1$[ebp], edx
  00051	8b 50 10	 mov	 edx, DWORD PTR [eax+16]
  00054	89 55 e8	 mov	 DWORD PTR _left$1$[ebp], edx
  00057	8b 51 38	 mov	 edx, DWORD PTR [ecx+56]
  0005a	57		 push	 edi
  0005b	8b 38		 mov	 edi, DWORD PTR [eax]

; 634  :     in = have;
; 635  :     out = left;

  0005d	8b 45 e8	 mov	 eax, DWORD PTR _left$1$[ebp]
  00060	89 45 dc	 mov	 DWORD PTR _out$1$[ebp], eax

; 636  :     ret = Z_OK;

  00063	33 c0		 xor	 eax, eax
  00065	89 45 d4	 mov	 DWORD PTR _ret$1$[ebp], eax

; 637  :     for (;;)
; 638  :         switch (state->mode) {

  00068	8b 01		 mov	 eax, DWORD PTR [ecx]
  0006a	89 7d f0	 mov	 DWORD PTR _next$1$[ebp], edi
  0006d	89 5d f4	 mov	 DWORD PTR _have$1$[ebp], ebx
  00070	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  00073	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi
  00076	89 5d c4	 mov	 DWORD PTR _in$1$[ebp], ebx
  00079	83 f8 1e	 cmp	 eax, 30			; 0000001eH
  0007c	0f 87 95 0a 00
	00		 ja	 $LN12@inflate

; 937  :                 for (;;) {
; 938  :                     here = state->lencode[BITS(state->lenbits)];

  00082	8d 79 54	 lea	 edi, DWORD PTR [ecx+84]
  00085	89 7d d0	 mov	 DWORD PTR tv2752[ebp], edi

; 1079 :         case DIST:
; 1080 :             for (;;) {
; 1081 :                 here = state->distcode[BITS(state->distbits)];

  00088	8d 79 58	 lea	 edi, DWORD PTR [ecx+88]
  0008b	89 7d c0	 mov	 DWORD PTR tv2749[ebp], edi
  0008e	8b 7d f0	 mov	 edi, DWORD PTR _next$1$[ebp]
$LL493@inflate:

; 637  :     for (;;)
; 638  :         switch (state->mode) {

  00091	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN901@inflate[eax*4]
$LN489@inflate:

; 639  :         case HEAD:
; 640  :             if (state->wrap == 0) {

  00098	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  0009b	89 45 c8	 mov	 DWORD PTR tv2730[ebp], eax
  0009e	85 c0		 test	 eax, eax
  000a0	75 0b		 jne	 SHORT $LN487@inflate

; 641  :                 state->mode = TYPEDO;

  000a2	c7 01 0c 00 00
	00		 mov	 DWORD PTR [ecx], 12	; 0000000cH

; 642  :                 break;

  000a8	e9 5f 0a 00 00	 jmp	 $LN490@inflate
$LN487@inflate:

; 643  :             }
; 644  :             NEEDBITS(16);

  000ad	83 fe 10	 cmp	 esi, 16			; 00000010H
  000b0	73 2d		 jae	 SHORT $LN486@inflate
$LL484@inflate:
  000b2	85 db		 test	 ebx, ebx
  000b4	0f 84 c0 04 00
	00		 je	 $LN852@inflate
  000ba	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  000bd	8b ce		 mov	 ecx, esi
  000bf	d3 e0		 shl	 eax, cl
  000c1	83 c6 08	 add	 esi, 8
  000c4	4b		 dec	 ebx
  000c5	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi
  000c8	03 d0		 add	 edx, eax
  000ca	89 5d f4	 mov	 DWORD PTR _have$1$[ebp], ebx
  000cd	47		 inc	 edi
  000ce	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  000d1	89 7d f0	 mov	 DWORD PTR _next$1$[ebp], edi
  000d4	83 fe 10	 cmp	 esi, 16			; 00000010H
  000d7	72 d9		 jb	 SHORT $LL484@inflate
  000d9	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  000dc	8b 45 c8	 mov	 eax, DWORD PTR tv2730[ebp]
$LN486@inflate:

; 645  : #ifdef GUNZIP
; 646  :             if ((state->wrap & 2) && hold == 0x8b1f) {  /* gzip header */

  000df	a8 02		 test	 al, 2
  000e1	74 46		 je	 SHORT $LN478@inflate
  000e3	81 fa 1f 8b 00
	00		 cmp	 edx, 35615		; 00008b1fH
  000e9	75 3e		 jne	 SHORT $LN478@inflate

; 647  :                 state->check = crc32(0L, Z_NULL, 0);

  000eb	6a 00		 push	 0
  000ed	6a 00		 push	 0
  000ef	6a 00		 push	 0
  000f1	e8 00 00 00 00	 call	 _crc32@12
  000f6	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]

; 648  :                 CRC2(state->check, hold);

  000f9	6a 02		 push	 2
  000fb	66 c7 45 e4 1f
	8b		 mov	 WORD PTR _hbuf$[ebp], 35615 ; 00008b1fH
  00101	89 41 18	 mov	 DWORD PTR [ecx+24], eax
  00104	8d 4d e4	 lea	 ecx, DWORD PTR _hbuf$[ebp]
  00107	51		 push	 ecx
  00108	50		 push	 eax
  00109	e8 00 00 00 00	 call	 _crc32@12
  0010e	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]

; 649  :                 INITBITS();

  00111	33 d2		 xor	 edx, edx
  00113	33 f6		 xor	 esi, esi
  00115	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  00118	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi
  0011b	89 41 18	 mov	 DWORD PTR [ecx+24], eax

; 650  :                 state->mode = FLAGS;

  0011e	c7 01 01 00 00
	00		 mov	 DWORD PTR [ecx], 1

; 651  :                 break;

  00124	e9 e3 09 00 00	 jmp	 $LN490@inflate
$LN478@inflate:

; 652  :             }
; 653  :             state->flags = 0;           /* expect zlib header */
; 654  :             if (state->head != Z_NULL)

  00129	8b 41 20	 mov	 eax, DWORD PTR [ecx+32]
  0012c	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0
  00133	85 c0		 test	 eax, eax
  00135	74 07		 je	 SHORT $LN471@inflate

; 655  :                 state->head->done = -1;

  00137	c7 40 30 ff ff
	ff ff		 mov	 DWORD PTR [eax+48], -1
$LN471@inflate:

; 656  :             if (!(state->wrap & 1) ||   /* check if zlib header allowed */
; 657  : #else
; 658  :             if (
; 659  : #endif
; 660  :                 ((BITS(8) << 8) + (hold >> 8)) % 31) {

  0013e	f6 41 08 01	 test	 BYTE PTR [ecx+8], 1
  00142	0f 84 c1 00 00
	00		 je	 $LN469@inflate
  00148	0f b6 ca	 movzx	 ecx, dl
  0014b	8b c2		 mov	 eax, edx
  0014d	c1 e1 08	 shl	 ecx, 8
  00150	33 d2		 xor	 edx, edx
  00152	c1 e8 08	 shr	 eax, 8
  00155	03 c1		 add	 eax, ecx
  00157	b9 1f 00 00 00	 mov	 ecx, 31			; 0000001fH
  0015c	f7 f1		 div	 ecx

; 667  :                 state->mode = BAD;

  0015e	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  00161	85 d2		 test	 edx, edx
  00163	8b 55 fc	 mov	 edx, DWORD PTR _hold$1$[ebp]
  00166	0f 85 9d 00 00
	00		 jne	 $LN469@inflate

; 664  :             }
; 665  :             if (BITS(4) != Z_DEFLATED) {

  0016c	8b c2		 mov	 eax, edx
  0016e	24 0f		 and	 al, 15			; 0000000fH
  00170	3c 08		 cmp	 al, 8
  00172	74 15		 je	 SHORT $LN467@inflate
$LN898@inflate:

; 666  :                 strm->msg = (char *)"unknown compression method";

  00174	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00177	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BL@IHKGDAEE@unknown?5compression?5method?$AA@

; 667  :                 state->mode = BAD;

  0017e	c7 01 1d 00 00
	00		 mov	 DWORD PTR [ecx], 29	; 0000001dH

; 668  :                 break;

  00184	e9 83 09 00 00	 jmp	 $LN490@inflate
$LN467@inflate:

; 669  :             }
; 670  :             DROPBITS(4);

  00189	c1 ea 04	 shr	 edx, 4
  0018c	83 ee 04	 sub	 esi, 4

; 671  :             len = BITS(4) + 8;

  0018f	8b c2		 mov	 eax, edx
  00191	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  00194	83 e0 0f	 and	 eax, 15			; 0000000fH
  00197	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi
  0019a	83 c0 08	 add	 eax, 8

; 672  :             if (state->wbits == 0)

  0019d	83 79 24 00	 cmp	 DWORD PTR [ecx+36], 0
  001a1	89 45 c8	 mov	 DWORD PTR _len$1$[ebp], eax
  001a4	75 49		 jne	 SHORT $LN464@inflate

; 673  :                 state->wbits = len;

  001a6	89 41 24	 mov	 DWORD PTR [ecx+36], eax
$LN462@inflate:

; 678  :             }
; 679  :             state->dmax = 1U << len;

  001a9	8b 4d c8	 mov	 ecx, DWORD PTR _len$1$[ebp]
  001ac	b8 01 00 00 00	 mov	 eax, 1
  001b1	d3 e0		 shl	 eax, cl
  001b3	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]

; 680  :             Tracev((stderr, "inflate:   zlib header ok\n"));
; 681  :             strm->adler = state->check = adler32(0L, Z_NULL, 0);

  001b6	6a 00		 push	 0
  001b8	6a 00		 push	 0
  001ba	6a 00		 push	 0
  001bc	89 41 14	 mov	 DWORD PTR [ecx+20], eax
  001bf	e8 00 00 00 00	 call	 _adler32@12
  001c4	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  001c7	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  001ca	89 41 18	 mov	 DWORD PTR [ecx+24], eax
  001cd	89 42 30	 mov	 DWORD PTR [edx+48], eax

; 682  :             state->mode = hold & 0x200 ? DICTID : TYPE;

  001d0	8b 55 fc	 mov	 edx, DWORD PTR _hold$1$[ebp]
  001d3	c1 ea 08	 shr	 edx, 8
  001d6	f7 d2		 not	 edx
  001d8	83 e2 02	 and	 edx, 2
  001db	83 ca 09	 or	 edx, 9
  001de	89 11		 mov	 DWORD PTR [ecx], edx

; 683  :             INITBITS();

  001e0	33 d2		 xor	 edx, edx
  001e2	33 f6		 xor	 esi, esi
  001e4	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  001e7	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi

; 684  :             break;

  001ea	e9 1d 09 00 00	 jmp	 $LN490@inflate
$LN464@inflate:

; 674  :             else if (len > state->wbits) {

  001ef	3b 41 24	 cmp	 eax, DWORD PTR [ecx+36]
  001f2	76 b5		 jbe	 SHORT $LN462@inflate

; 675  :                 strm->msg = (char *)"invalid window size";

  001f4	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  001f7	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BE@EMOGCLGO@invalid?5window?5size?$AA@

; 676  :                 state->mode = BAD;

  001fe	c7 01 1d 00 00
	00		 mov	 DWORD PTR [ecx], 29	; 0000001dH

; 677  :                 break;

  00204	e9 03 09 00 00	 jmp	 $LN490@inflate
$LN469@inflate:

; 661  :                 strm->msg = (char *)"incorrect header check";

  00209	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  0020c	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BH@LIBMMIGA@incorrect?5header?5check?$AA@

; 662  :                 state->mode = BAD;

  00213	c7 01 1d 00 00
	00		 mov	 DWORD PTR [ecx], 29	; 0000001dH

; 663  :                 break;

  00219	e9 ee 08 00 00	 jmp	 $LN490@inflate
$LN457@inflate:

; 685  : #ifdef GUNZIP
; 686  :         case FLAGS:
; 687  :             NEEDBITS(16);

  0021e	83 fe 10	 cmp	 esi, 16			; 00000010H
  00221	73 2a		 jae	 SHORT $LN456@inflate
$LL454@inflate:
  00223	85 db		 test	 ebx, ebx
  00225	0f 84 4f 03 00
	00		 je	 $LN852@inflate
  0022b	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  0022e	8b ce		 mov	 ecx, esi
  00230	d3 e0		 shl	 eax, cl
  00232	83 c6 08	 add	 esi, 8
  00235	4b		 dec	 ebx
  00236	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi
  00239	03 d0		 add	 edx, eax
  0023b	89 5d f4	 mov	 DWORD PTR _have$1$[ebp], ebx
  0023e	47		 inc	 edi
  0023f	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  00242	89 7d f0	 mov	 DWORD PTR _next$1$[ebp], edi
  00245	83 fe 10	 cmp	 esi, 16			; 00000010H
  00248	72 d9		 jb	 SHORT $LL454@inflate
  0024a	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
$LN456@inflate:

; 688  :             state->flags = (int)(hold);

  0024d	89 51 10	 mov	 DWORD PTR [ecx+16], edx

; 689  :             if ((state->flags & 0xff) != Z_DEFLATED) {

  00250	80 fa 08	 cmp	 dl, 8
  00253	0f 85 1b ff ff
	ff		 jne	 $LN898@inflate

; 690  :                 strm->msg = (char *)"unknown compression method";
; 691  :                 state->mode = BAD;
; 692  :                 break;
; 693  :             }
; 694  :             if (state->flags & 0xe000) {

  00259	f7 c2 00 e0 00
	00		 test	 edx, 57344		; 0000e000H
  0025f	74 15		 je	 SHORT $LN447@inflate

; 695  :                 strm->msg = (char *)"unknown header flags set";

  00261	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00264	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BJ@BLBBCOMO@unknown?5header?5flags?5set?$AA@
  0026b	c7 01 1d 00 00
	00		 mov	 DWORD PTR [ecx], 29	; 0000001dH
  00271	e9 96 08 00 00	 jmp	 $LN490@inflate
$LN447@inflate:

; 696  :                 state->mode = BAD;
; 697  :                 break;
; 698  :             }
; 699  :             if (state->head != Z_NULL)

  00276	8b 71 20	 mov	 esi, DWORD PTR [ecx+32]
  00279	85 f6		 test	 esi, esi
  0027b	74 0a		 je	 SHORT $LN446@inflate

; 700  :                 state->head->text = (int)((hold >> 8) & 1);

  0027d	8b c2		 mov	 eax, edx
  0027f	c1 e8 08	 shr	 eax, 8
  00282	83 e0 01	 and	 eax, 1
  00285	89 06		 mov	 DWORD PTR [esi], eax
$LN446@inflate:

; 701  :             if (state->flags & 0x0200) CRC2(state->check, hold);

  00287	f7 41 10 00 02
	00 00		 test	 DWORD PTR [ecx+16], 512	; 00000200H
  0028e	74 1d		 je	 SHORT $LN442@inflate
  00290	6a 02		 push	 2
  00292	8d 45 e4	 lea	 eax, DWORD PTR _hbuf$[ebp]
  00295	88 55 e4	 mov	 BYTE PTR _hbuf$[ebp], dl
  00298	50		 push	 eax
  00299	ff 71 18	 push	 DWORD PTR [ecx+24]
  0029c	c1 ea 08	 shr	 edx, 8
  0029f	88 55 e5	 mov	 BYTE PTR _hbuf$[ebp+1], dl
  002a2	e8 00 00 00 00	 call	 _crc32@12
  002a7	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  002aa	89 41 18	 mov	 DWORD PTR [ecx+24], eax
$LN442@inflate:

; 702  :             INITBITS();

  002ad	33 d2		 xor	 edx, edx

; 703  :             state->mode = TIME;

  002af	c7 01 02 00 00
	00		 mov	 DWORD PTR [ecx], 2
  002b5	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  002b8	33 f6		 xor	 esi, esi

; 704  :         case TIME:
; 705  :             NEEDBITS(32);

  002ba	eb 05		 jmp	 SHORT $LL434@inflate
$LN437@inflate:
  002bc	83 fe 20	 cmp	 esi, 32			; 00000020H
  002bf	73 27		 jae	 SHORT $LN436@inflate
$LL434@inflate:
  002c1	85 db		 test	 ebx, ebx
  002c3	0f 84 b1 02 00
	00		 je	 $LN852@inflate
  002c9	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  002cc	8b ce		 mov	 ecx, esi
  002ce	d3 e0		 shl	 eax, cl
  002d0	4b		 dec	 ebx
  002d1	03 d0		 add	 edx, eax
  002d3	89 5d f4	 mov	 DWORD PTR _have$1$[ebp], ebx
  002d6	47		 inc	 edi
  002d7	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  002da	83 c6 08	 add	 esi, 8
  002dd	89 7d f0	 mov	 DWORD PTR _next$1$[ebp], edi
  002e0	83 fe 20	 cmp	 esi, 32			; 00000020H
  002e3	72 dc		 jb	 SHORT $LL434@inflate
  002e5	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
$LN436@inflate:

; 706  :             if (state->head != Z_NULL)

  002e8	8b 41 20	 mov	 eax, DWORD PTR [ecx+32]
  002eb	85 c0		 test	 eax, eax
  002ed	74 03		 je	 SHORT $LN428@inflate

; 707  :                 state->head->time = hold;

  002ef	89 50 04	 mov	 DWORD PTR [eax+4], edx
$LN428@inflate:

; 708  :             if (state->flags & 0x0200) CRC4(state->check, hold);

  002f2	f7 41 10 00 02
	00 00		 test	 DWORD PTR [ecx+16], 512	; 00000200H
  002f9	74 2d		 je	 SHORT $LN424@inflate
  002fb	8b c2		 mov	 eax, edx
  002fd	88 55 e4	 mov	 BYTE PTR _hbuf$[ebp], dl
  00300	c1 e8 08	 shr	 eax, 8
  00303	88 45 e5	 mov	 BYTE PTR _hbuf$[ebp+1], al
  00306	8b c2		 mov	 eax, edx
  00308	c1 e8 10	 shr	 eax, 16			; 00000010H
  0030b	88 45 e6	 mov	 BYTE PTR _hbuf$[ebp+2], al
  0030e	8d 45 e4	 lea	 eax, DWORD PTR _hbuf$[ebp]
  00311	6a 04		 push	 4
  00313	50		 push	 eax
  00314	ff 71 18	 push	 DWORD PTR [ecx+24]
  00317	c1 ea 18	 shr	 edx, 24			; 00000018H
  0031a	88 55 e7	 mov	 BYTE PTR _hbuf$[ebp+3], dl
  0031d	e8 00 00 00 00	 call	 _crc32@12
  00322	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  00325	89 41 18	 mov	 DWORD PTR [ecx+24], eax
$LN424@inflate:

; 709  :             INITBITS();

  00328	33 d2		 xor	 edx, edx

; 710  :             state->mode = OS;

  0032a	c7 01 03 00 00
	00		 mov	 DWORD PTR [ecx], 3
  00330	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  00333	33 f6		 xor	 esi, esi

; 711  :         case OS:
; 712  :             NEEDBITS(16);

  00335	eb 09		 jmp	 SHORT $LL416@inflate
$LN419@inflate:
  00337	83 fe 10	 cmp	 esi, 16			; 00000010H
  0033a	73 2b		 jae	 SHORT $LN418@inflate
  0033c	8d 64 24 00	 npad	 4
$LL416@inflate:
  00340	85 db		 test	 ebx, ebx
  00342	0f 84 32 02 00
	00		 je	 $LN852@inflate
  00348	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  0034b	8b ce		 mov	 ecx, esi
  0034d	d3 e0		 shl	 eax, cl
  0034f	4b		 dec	 ebx
  00350	03 d0		 add	 edx, eax
  00352	89 5d f4	 mov	 DWORD PTR _have$1$[ebp], ebx
  00355	47		 inc	 edi
  00356	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  00359	83 c6 08	 add	 esi, 8
  0035c	89 7d f0	 mov	 DWORD PTR _next$1$[ebp], edi
  0035f	83 fe 10	 cmp	 esi, 16			; 00000010H
  00362	72 dc		 jb	 SHORT $LL416@inflate
  00364	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
$LN418@inflate:

; 713  :             if (state->head != Z_NULL) {

  00367	8b 71 20	 mov	 esi, DWORD PTR [ecx+32]
  0036a	85 f6		 test	 esi, esi
  0036c	74 17		 je	 SHORT $LN410@inflate

; 714  :                 state->head->xflags = (int)(hold & 0xff);

  0036e	0f b6 c2	 movzx	 eax, dl

; 715  :                 state->head->os = (int)(hold >> 8);

  00371	8b ca		 mov	 ecx, edx
  00373	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00376	8b 45 f8	 mov	 eax, DWORD PTR _state$1$[ebp]
  00379	c1 e9 08	 shr	 ecx, 8
  0037c	8b 40 20	 mov	 eax, DWORD PTR [eax+32]
  0037f	89 48 0c	 mov	 DWORD PTR [eax+12], ecx
  00382	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
$LN410@inflate:

; 716  :             }
; 717  :             if (state->flags & 0x0200) CRC2(state->check, hold);

  00385	f7 41 10 00 02
	00 00		 test	 DWORD PTR [ecx+16], 512	; 00000200H
  0038c	74 1d		 je	 SHORT $LN406@inflate
  0038e	6a 02		 push	 2
  00390	8d 45 e4	 lea	 eax, DWORD PTR _hbuf$[ebp]
  00393	88 55 e4	 mov	 BYTE PTR _hbuf$[ebp], dl
  00396	50		 push	 eax
  00397	ff 71 18	 push	 DWORD PTR [ecx+24]
  0039a	c1 ea 08	 shr	 edx, 8
  0039d	88 55 e5	 mov	 BYTE PTR _hbuf$[ebp+1], dl
  003a0	e8 00 00 00 00	 call	 _crc32@12
  003a5	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  003a8	89 41 18	 mov	 DWORD PTR [ecx+24], eax
$LN406@inflate:

; 718  :             INITBITS();

  003ab	33 d2		 xor	 edx, edx

; 719  :             state->mode = EXLEN;

  003ad	c7 01 04 00 00
	00		 mov	 DWORD PTR [ecx], 4
  003b3	33 f6		 xor	 esi, esi
  003b5	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  003b8	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi
$LN402@inflate:

; 720  :         case EXLEN:
; 721  :             if (state->flags & 0x0400) {

  003bb	f7 41 10 00 04
	00 00		 test	 DWORD PTR [ecx+16], 1024 ; 00000400H
  003c2	74 74		 je	 SHORT $LN401@inflate

; 722  :                 NEEDBITS(16);

  003c4	83 fe 10	 cmp	 esi, 16			; 00000010H
  003c7	73 2e		 jae	 SHORT $LN399@inflate
  003c9	8d a4 24 00 00
	00 00		 npad	 7
$LL397@inflate:
  003d0	85 db		 test	 ebx, ebx
  003d2	0f 84 a2 01 00
	00		 je	 $LN852@inflate
  003d8	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  003db	8b ce		 mov	 ecx, esi
  003dd	d3 e0		 shl	 eax, cl
  003df	4b		 dec	 ebx
  003e0	03 d0		 add	 edx, eax
  003e2	89 5d f4	 mov	 DWORD PTR _have$1$[ebp], ebx
  003e5	47		 inc	 edi
  003e6	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  003e9	83 c6 08	 add	 esi, 8
  003ec	89 7d f0	 mov	 DWORD PTR _next$1$[ebp], edi
  003ef	83 fe 10	 cmp	 esi, 16			; 00000010H
  003f2	72 dc		 jb	 SHORT $LL397@inflate
  003f4	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
$LN399@inflate:

; 723  :                 state->length = (unsigned)(hold);
; 724  :                 if (state->head != Z_NULL)

  003f7	8b 41 20	 mov	 eax, DWORD PTR [ecx+32]
  003fa	89 51 40	 mov	 DWORD PTR [ecx+64], edx
  003fd	85 c0		 test	 eax, eax
  003ff	74 03		 je	 SHORT $LN391@inflate

; 725  :                     state->head->extra_len = (unsigned)hold;

  00401	89 50 14	 mov	 DWORD PTR [eax+20], edx
$LN391@inflate:

; 726  :                 if (state->flags & 0x0200) CRC2(state->check, hold);

  00404	f7 41 10 00 02
	00 00		 test	 DWORD PTR [ecx+16], 512	; 00000200H
  0040b	74 1d		 je	 SHORT $LN387@inflate
  0040d	6a 02		 push	 2
  0040f	8d 45 e4	 lea	 eax, DWORD PTR _hbuf$[ebp]
  00412	88 55 e4	 mov	 BYTE PTR _hbuf$[ebp], dl
  00415	50		 push	 eax
  00416	ff 71 18	 push	 DWORD PTR [ecx+24]
  00419	c1 ea 08	 shr	 edx, 8
  0041c	88 55 e5	 mov	 BYTE PTR _hbuf$[ebp+1], dl
  0041f	e8 00 00 00 00	 call	 _crc32@12
  00424	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  00427	89 41 18	 mov	 DWORD PTR [ecx+24], eax
$LN387@inflate:

; 727  :                 INITBITS();

  0042a	33 f6		 xor	 esi, esi
  0042c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _hold$1$[ebp], 0
  00433	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi

; 728  :             }
; 729  :             else if (state->head != Z_NULL)

  00436	eb 0e		 jmp	 SHORT $LN382@inflate
$LN401@inflate:
  00438	8b 41 20	 mov	 eax, DWORD PTR [ecx+32]
  0043b	85 c0		 test	 eax, eax
  0043d	74 07		 je	 SHORT $LN382@inflate

; 730  :                 state->head->extra = Z_NULL;

  0043f	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [eax+16], 0
$LN382@inflate:

; 731  :             state->mode = EXTRA;

  00446	c7 01 05 00 00
	00		 mov	 DWORD PTR [ecx], 5
$LN381@inflate:

; 732  :         case EXTRA:
; 733  :             if (state->flags & 0x0400) {

  0044c	f7 41 10 00 04
	00 00		 test	 DWORD PTR [ecx+16], 1024 ; 00000400H
  00453	0f 84 8d 00 00
	00		 je	 $LN375@inflate

; 734  :                 copy = state->length;

  00459	8b 41 40	 mov	 eax, DWORD PTR [ecx+64]

; 735  :                 if (copy > have) copy = have;

  0045c	3b c3		 cmp	 eax, ebx
  0045e	8b d0		 mov	 edx, eax
  00460	89 45 cc	 mov	 DWORD PTR _copy$1$[ebp], eax
  00463	0f 47 d3	 cmova	 edx, ebx
  00466	89 55 c8	 mov	 DWORD PTR _copy$2$[ebp], edx

; 736  :                 if (copy) {

  00469	85 d2		 test	 edx, edx
  0046b	74 6f		 je	 SHORT $LN378@inflate

; 737  :                     if (state->head != Z_NULL &&
; 738  :                         state->head->extra != Z_NULL) {

  0046d	8b 41 20	 mov	 eax, DWORD PTR [ecx+32]
  00470	85 c0		 test	 eax, eax
  00472	74 3f		 je	 SHORT $LN377@inflate
  00474	8b 78 10	 mov	 edi, DWORD PTR [eax+16]
  00477	85 ff		 test	 edi, edi
  00479	89 7d f4	 mov	 DWORD PTR tv2686[ebp], edi
  0047c	8b 7d f0	 mov	 edi, DWORD PTR _next$1$[ebp]
  0047f	74 32		 je	 SHORT $LN377@inflate

; 739  :                         len = state->head->extra_len - state->length;

  00481	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00484	2b 4d cc	 sub	 ecx, DWORD PTR _copy$1$[ebp]
  00487	89 4d d8	 mov	 DWORD PTR _len$2$[ebp], ecx

; 740  :                         zmemcpy(state->head->extra + len, next,
; 741  :                                 len + copy > state->head->extra_max ?
; 742  :                                 state->head->extra_max - len : copy);

  0048a	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  0048d	8b 45 d8	 mov	 eax, DWORD PTR _len$2$[ebp]
  00490	03 c2		 add	 eax, edx
  00492	3b c1		 cmp	 eax, ecx
  00494	8b 45 d8	 mov	 eax, DWORD PTR _len$2$[ebp]
  00497	76 04		 jbe	 SHORT $LN502@inflate
  00499	2b c8		 sub	 ecx, eax
  0049b	eb 02		 jmp	 SHORT $LN503@inflate
$LN502@inflate:
  0049d	8b ca		 mov	 ecx, edx
$LN503@inflate:
  0049f	03 45 f4	 add	 eax, DWORD PTR tv2686[ebp]
  004a2	51		 push	 ecx
  004a3	57		 push	 edi
  004a4	50		 push	 eax
  004a5	e8 00 00 00 00	 call	 _memcpy
  004aa	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  004ad	83 c4 0c	 add	 esp, 12			; 0000000cH
  004b0	8b 55 c8	 mov	 edx, DWORD PTR _copy$2$[ebp]
$LN377@inflate:

; 743  :                     }
; 744  :                     if (state->flags & 0x0200)

  004b3	f7 41 10 00 02
	00 00		 test	 DWORD PTR [ecx+16], 512	; 00000200H
  004ba	74 10		 je	 SHORT $LN376@inflate

; 745  :                         state->check = crc32(state->check, next, copy);

  004bc	52		 push	 edx
  004bd	57		 push	 edi
  004be	ff 71 18	 push	 DWORD PTR [ecx+24]
  004c1	e8 00 00 00 00	 call	 _crc32@12
  004c6	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  004c9	89 41 18	 mov	 DWORD PTR [ecx+24], eax
$LN376@inflate:

; 746  :                     have -= copy;

  004cc	8b 45 c8	 mov	 eax, DWORD PTR _copy$2$[ebp]
  004cf	2b d8		 sub	 ebx, eax

; 747  :                     next += copy;

  004d1	03 f8		 add	 edi, eax
  004d3	89 5d f4	 mov	 DWORD PTR _have$1$[ebp], ebx

; 748  :                     state->length -= copy;

  004d6	29 41 40	 sub	 DWORD PTR [ecx+64], eax
  004d9	89 7d f0	 mov	 DWORD PTR _next$1$[ebp], edi
$LN378@inflate:

; 749  :                 }
; 750  :                 if (state->length) goto inf_leave;

  004dc	83 79 40 00	 cmp	 DWORD PTR [ecx+64], 0
  004e0	0f 85 94 00 00
	00		 jne	 $LN852@inflate
$LN375@inflate:

; 751  :             }
; 752  :             state->length = 0;

  004e6	c7 41 40 00 00
	00 00		 mov	 DWORD PTR [ecx+64], 0

; 753  :             state->mode = NAME;

  004ed	c7 01 06 00 00
	00		 mov	 DWORD PTR [ecx], 6
$LN374@inflate:

; 754  :         case NAME:
; 755  :             if (state->flags & 0x0800) {

  004f3	f7 41 10 00 08
	00 00		 test	 DWORD PTR [ecx+16], 2048 ; 00000800H
  004fa	0f 84 f3 00 00
	00		 je	 $LN373@inflate

; 756  :                 if (have == 0) goto inf_leave;

  00500	85 db		 test	 ebx, ebx
  00502	74 76		 je	 SHORT $LN852@inflate

; 757  :                 copy = 0;

  00504	33 d2		 xor	 edx, edx
$LL371@inflate:

; 758  :                 do {
; 759  :                     len = (unsigned)(next[copy++]);

  00506	0f b6 04 3a	 movzx	 eax, BYTE PTR [edx+edi]
  0050a	42		 inc	 edx
  0050b	89 45 d8	 mov	 DWORD PTR _len$3$[ebp], eax

; 760  :                     if (state->head != Z_NULL &&
; 761  :                             state->head->name != Z_NULL &&
; 762  :                             state->length < state->head->name_max)

  0050e	8b 41 20	 mov	 eax, DWORD PTR [ecx+32]
  00511	85 c0		 test	 eax, eax
  00513	74 23		 je	 SHORT $LN370@inflate
  00515	8b 70 1c	 mov	 esi, DWORD PTR [eax+28]
  00518	89 75 cc	 mov	 DWORD PTR tv2683[ebp], esi
  0051b	85 f6		 test	 esi, esi
  0051d	74 19		 je	 SHORT $LN370@inflate
  0051f	8b 71 40	 mov	 esi, DWORD PTR [ecx+64]
  00522	3b 70 20	 cmp	 esi, DWORD PTR [eax+32]
  00525	73 11		 jae	 SHORT $LN370@inflate

; 763  :                         state->head->name[state->length++] = len;

  00527	8b 5d d8	 mov	 ebx, DWORD PTR _len$3$[ebp]
  0052a	8b c6		 mov	 eax, esi
  0052c	8b 75 cc	 mov	 esi, DWORD PTR tv2683[ebp]
  0052f	88 1c 06	 mov	 BYTE PTR [esi+eax], bl
  00532	ff 41 40	 inc	 DWORD PTR [ecx+64]
  00535	8b 5d f4	 mov	 ebx, DWORD PTR _have$1$[ebp]
$LN370@inflate:

; 764  :                 } while (len && copy < have);

  00538	8b 45 d8	 mov	 eax, DWORD PTR _len$3$[ebp]
  0053b	85 c0		 test	 eax, eax
  0053d	74 04		 je	 SHORT $LN367@inflate
  0053f	3b d3		 cmp	 edx, ebx
  00541	72 c3		 jb	 SHORT $LL371@inflate
$LN367@inflate:

; 765  :                 if (state->flags & 0x0200)

  00543	f7 41 10 00 02
	00 00		 test	 DWORD PTR [ecx+16], 512	; 00000200H
  0054a	8b 75 ec	 mov	 esi, DWORD PTR _bits$1$[ebp]
  0054d	89 55 c8	 mov	 DWORD PTR _copy$3$[ebp], edx
  00550	74 16		 je	 SHORT $LN366@inflate

; 766  :                     state->check = crc32(state->check, next, copy);

  00552	52		 push	 edx
  00553	57		 push	 edi
  00554	ff 71 18	 push	 DWORD PTR [ecx+24]
  00557	e8 00 00 00 00	 call	 _crc32@12
  0055c	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  0055f	8b 55 c8	 mov	 edx, DWORD PTR _copy$3$[ebp]
  00562	89 41 18	 mov	 DWORD PTR [ecx+24], eax
  00565	8b 45 d8	 mov	 eax, DWORD PTR _len$3$[ebp]
$LN366@inflate:

; 767  :                 have -= copy;

  00568	2b da		 sub	 ebx, edx

; 768  :                 next += copy;

  0056a	03 fa		 add	 edi, edx
  0056c	89 5d f4	 mov	 DWORD PTR _have$1$[ebp], ebx
  0056f	89 7d f0	 mov	 DWORD PTR _next$1$[ebp], edi

; 769  :                 if (len) goto inf_leave;

  00572	85 c0		 test	 eax, eax
  00574	0f 84 87 00 00
	00		 je	 $LN363@inflate
$LN852@inflate:
  0057a	8b 45 f4	 mov	 eax, DWORD PTR _have$1$[ebp]
$LN862@inflate:
  0057d	8b 55 0c	 mov	 edx, DWORD PTR _flush$[ebp]
$inf_leave$903:

; 1221 :         }
; 1222 : 
; 1223 :     /*
; 1224 :        Return from inflate(), updating the total counts and the check value.
; 1225 :        If there was no progress during the inflate() call, return a buffer
; 1226 :        error.  Call updatewindow() to create and/or update the window state.
; 1227 :        Note: a memory error from inflate() is non-recoverable.
; 1228 :      */
; 1229 :   inf_leave:
; 1230 :     RESTORE();

  00580	8b 7d 08	 mov	 edi, DWORD PTR _strm$[ebp]
  00583	8b 4d e0	 mov	 ecx, DWORD PTR _put$1$[ebp]
  00586	8b 5d f8	 mov	 ebx, DWORD PTR _state$1$[ebp]
  00589	89 4f 0c	 mov	 DWORD PTR [edi+12], ecx
  0058c	8b 4d e8	 mov	 ecx, DWORD PTR _left$1$[ebp]
  0058f	89 4f 10	 mov	 DWORD PTR [edi+16], ecx
  00592	8b 4d f0	 mov	 ecx, DWORD PTR _next$1$[ebp]
  00595	89 47 04	 mov	 DWORD PTR [edi+4], eax
  00598	8b 45 fc	 mov	 eax, DWORD PTR _hold$1$[ebp]
  0059b	89 0f		 mov	 DWORD PTR [edi], ecx

; 1231 :     if (state->wsize || (out != strm->avail_out && state->mode < BAD &&
; 1232 :             (state->mode < CHECK || flush != Z_FINISH)))

  0059d	83 7b 28 00	 cmp	 DWORD PTR [ebx+40], 0
  005a1	89 73 3c	 mov	 DWORD PTR [ebx+60], esi
  005a4	8b 75 dc	 mov	 esi, DWORD PTR _out$1$[ebp]
  005a7	89 43 38	 mov	 DWORD PTR [ebx+56], eax
  005aa	75 22		 jne	 SHORT $LN6@inflate
  005ac	3b 77 10	 cmp	 esi, DWORD PTR [edi+16]
  005af	0f 84 b9 0f 00
	00		 je	 $LN5@inflate
  005b5	8b 03		 mov	 eax, DWORD PTR [ebx]
  005b7	83 f8 1d	 cmp	 eax, 29			; 0000001dH
  005ba	0f 8d ae 0f 00
	00		 jge	 $LN5@inflate
  005c0	83 f8 1a	 cmp	 eax, 26			; 0000001aH
  005c3	7c 09		 jl	 SHORT $LN6@inflate
  005c5	83 fa 04	 cmp	 edx, 4
  005c8	0f 84 a0 0f 00
	00		 je	 $LN5@inflate
$LN6@inflate:

; 1233 :         if (updatewindow(strm, out)) {

  005ce	8b d6		 mov	 edx, esi
  005d0	8b cf		 mov	 ecx, edi
  005d2	e8 00 00 00 00	 call	 _updatewindow
  005d7	85 c0		 test	 eax, eax
  005d9	0f 84 8f 0f 00
	00		 je	 $LN5@inflate

; 1234 :             state->mode = MEM;

  005df	c7 03 1e 00 00
	00		 mov	 DWORD PTR [ebx], 30	; 0000001eH
$LN13@inflate:
  005e5	5f		 pop	 edi
  005e6	5e		 pop	 esi

; 1235 :             return Z_MEM_ERROR;

  005e7	b8 fc ff ff ff	 mov	 eax, -4			; fffffffcH
  005ec	5b		 pop	 ebx

; 1249 :         ret = Z_BUF_ERROR;
; 1250 :     return ret;
; 1251 : }

  005ed	8b e5		 mov	 esp, ebp
  005ef	5d		 pop	 ebp
  005f0	c2 08 00	 ret	 8
$LN373@inflate:

; 770  :             }
; 771  :             else if (state->head != Z_NULL)

  005f3	8b 41 20	 mov	 eax, DWORD PTR [ecx+32]
  005f6	85 c0		 test	 eax, eax
  005f8	74 07		 je	 SHORT $LN363@inflate

; 772  :                 state->head->name = Z_NULL;

  005fa	c7 40 1c 00 00
	00 00		 mov	 DWORD PTR [eax+28], 0
$LN363@inflate:

; 773  :             state->length = 0;

  00601	c7 41 40 00 00
	00 00		 mov	 DWORD PTR [ecx+64], 0

; 774  :             state->mode = COMMENT;

  00608	c7 01 07 00 00
	00		 mov	 DWORD PTR [ecx], 7
$LN362@inflate:

; 775  :         case COMMENT:
; 776  :             if (state->flags & 0x1000) {

  0060e	f7 41 10 00 10
	00 00		 test	 DWORD PTR [ecx+16], 4096 ; 00001000H
  00615	0f 84 80 00 00
	00		 je	 $LN361@inflate

; 777  :                 if (have == 0) goto inf_leave;

  0061b	85 db		 test	 ebx, ebx
  0061d	0f 84 57 ff ff
	ff		 je	 $LN852@inflate

; 778  :                 copy = 0;

  00623	33 d2		 xor	 edx, edx
$LL359@inflate:

; 779  :                 do {
; 780  :                     len = (unsigned)(next[copy++]);

  00625	0f b6 04 3a	 movzx	 eax, BYTE PTR [edx+edi]
  00629	42		 inc	 edx
  0062a	89 45 d8	 mov	 DWORD PTR _len$4$[ebp], eax

; 781  :                     if (state->head != Z_NULL &&
; 782  :                             state->head->comment != Z_NULL &&
; 783  :                             state->length < state->head->comm_max)

  0062d	8b 41 20	 mov	 eax, DWORD PTR [ecx+32]
  00630	85 c0		 test	 eax, eax
  00632	74 23		 je	 SHORT $LN358@inflate
  00634	8b 70 24	 mov	 esi, DWORD PTR [eax+36]
  00637	89 75 cc	 mov	 DWORD PTR tv2682[ebp], esi
  0063a	85 f6		 test	 esi, esi
  0063c	74 19		 je	 SHORT $LN358@inflate
  0063e	8b 71 40	 mov	 esi, DWORD PTR [ecx+64]
  00641	3b 70 28	 cmp	 esi, DWORD PTR [eax+40]
  00644	73 11		 jae	 SHORT $LN358@inflate

; 784  :                         state->head->comment[state->length++] = len;

  00646	8b 5d d8	 mov	 ebx, DWORD PTR _len$4$[ebp]
  00649	8b c6		 mov	 eax, esi
  0064b	8b 75 cc	 mov	 esi, DWORD PTR tv2682[ebp]
  0064e	88 1c 06	 mov	 BYTE PTR [esi+eax], bl
  00651	ff 41 40	 inc	 DWORD PTR [ecx+64]
  00654	8b 5d f4	 mov	 ebx, DWORD PTR _have$1$[ebp]
$LN358@inflate:

; 785  :                 } while (len && copy < have);

  00657	8b 45 d8	 mov	 eax, DWORD PTR _len$4$[ebp]
  0065a	85 c0		 test	 eax, eax
  0065c	74 04		 je	 SHORT $LN355@inflate
  0065e	3b d3		 cmp	 edx, ebx
  00660	72 c3		 jb	 SHORT $LL359@inflate
$LN355@inflate:

; 786  :                 if (state->flags & 0x0200)

  00662	f7 41 10 00 02
	00 00		 test	 DWORD PTR [ecx+16], 512	; 00000200H
  00669	8b 75 ec	 mov	 esi, DWORD PTR _bits$1$[ebp]
  0066c	89 55 c8	 mov	 DWORD PTR _copy$4$[ebp], edx
  0066f	74 16		 je	 SHORT $LN354@inflate

; 787  :                     state->check = crc32(state->check, next, copy);

  00671	52		 push	 edx
  00672	57		 push	 edi
  00673	ff 71 18	 push	 DWORD PTR [ecx+24]
  00676	e8 00 00 00 00	 call	 _crc32@12
  0067b	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  0067e	8b 55 c8	 mov	 edx, DWORD PTR _copy$4$[ebp]
  00681	89 41 18	 mov	 DWORD PTR [ecx+24], eax
  00684	8b 45 d8	 mov	 eax, DWORD PTR _len$4$[ebp]
$LN354@inflate:

; 788  :                 have -= copy;

  00687	2b da		 sub	 ebx, edx

; 789  :                 next += copy;

  00689	03 fa		 add	 edi, edx
  0068b	89 5d f4	 mov	 DWORD PTR _have$1$[ebp], ebx
  0068e	89 7d f0	 mov	 DWORD PTR _next$1$[ebp], edi

; 790  :                 if (len) goto inf_leave;

  00691	85 c0		 test	 eax, eax
  00693	0f 85 e1 fe ff
	ff		 jne	 $LN852@inflate

; 791  :             }
; 792  :             else if (state->head != Z_NULL)

  00699	eb 0e		 jmp	 SHORT $LN351@inflate
$LN361@inflate:
  0069b	8b 41 20	 mov	 eax, DWORD PTR [ecx+32]
  0069e	85 c0		 test	 eax, eax
  006a0	74 07		 je	 SHORT $LN351@inflate

; 793  :                 state->head->comment = Z_NULL;

  006a2	c7 40 24 00 00
	00 00		 mov	 DWORD PTR [eax+36], 0
$LN351@inflate:
  006a9	8b 55 fc	 mov	 edx, DWORD PTR _hold$1$[ebp]

; 794  :             state->mode = HCRC;

  006ac	c7 01 08 00 00
	00		 mov	 DWORD PTR [ecx], 8
$LN350@inflate:

; 795  :         case HCRC:
; 796  :             if (state->flags & 0x0200) {

  006b2	f7 41 10 00 02
	00 00		 test	 DWORD PTR [ecx+16], 512	; 00000200H
  006b9	74 58		 je	 SHORT $LN336@inflate

; 797  :                 NEEDBITS(16);

  006bb	83 fe 10	 cmp	 esi, 16			; 00000010H
  006be	73 2a		 jae	 SHORT $LN347@inflate
$LL345@inflate:
  006c0	85 db		 test	 ebx, ebx
  006c2	0f 84 b2 fe ff
	ff		 je	 $LN852@inflate
  006c8	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  006cb	8b ce		 mov	 ecx, esi
  006cd	d3 e0		 shl	 eax, cl
  006cf	83 c6 08	 add	 esi, 8
  006d2	4b		 dec	 ebx
  006d3	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi
  006d6	03 d0		 add	 edx, eax
  006d8	89 5d f4	 mov	 DWORD PTR _have$1$[ebp], ebx
  006db	47		 inc	 edi
  006dc	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  006df	89 7d f0	 mov	 DWORD PTR _next$1$[ebp], edi
  006e2	83 fe 10	 cmp	 esi, 16			; 00000010H
  006e5	72 d9		 jb	 SHORT $LL345@inflate
  006e7	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
$LN347@inflate:

; 798  :                 if (hold != (state->check & 0xffff)) {

  006ea	0f b7 41 18	 movzx	 eax, WORD PTR [ecx+24]
  006ee	3b d0		 cmp	 edx, eax
  006f0	74 15		 je	 SHORT $LN338@inflate

; 799  :                     strm->msg = (char *)"header crc mismatch";

  006f2	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  006f5	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BE@GONKLEPM@header?5crc?5mismatch?$AA@
  006fc	c7 01 1d 00 00
	00		 mov	 DWORD PTR [ecx], 29	; 0000001dH
  00702	e9 05 04 00 00	 jmp	 $LN490@inflate
$LN338@inflate:

; 800  :                     state->mode = BAD;
; 801  :                     break;
; 802  :                 }
; 803  :                 INITBITS();

  00707	33 f6		 xor	 esi, esi
  00709	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _hold$1$[ebp], 0
  00710	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi
$LN336@inflate:

; 804  :             }
; 805  :             if (state->head != Z_NULL) {

  00713	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  00716	85 d2		 test	 edx, edx
  00718	74 16		 je	 SHORT $LN335@inflate

; 806  :                 state->head->hcrc = (int)((state->flags >> 9) & 1);

  0071a	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  0071d	c1 f8 09	 sar	 eax, 9
  00720	83 e0 01	 and	 eax, 1
  00723	89 42 2c	 mov	 DWORD PTR [edx+44], eax

; 807  :                 state->head->done = 1;

  00726	8b 41 20	 mov	 eax, DWORD PTR [ecx+32]
  00729	c7 40 30 01 00
	00 00		 mov	 DWORD PTR [eax+48], 1
$LN335@inflate:

; 808  :             }
; 809  :             strm->adler = state->check = crc32(0L, Z_NULL, 0);

  00730	6a 00		 push	 0
  00732	6a 00		 push	 0
  00734	6a 00		 push	 0
  00736	e8 00 00 00 00	 call	 _crc32@12
  0073b	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  0073e	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  00741	89 41 18	 mov	 DWORD PTR [ecx+24], eax
  00744	89 42 30	 mov	 DWORD PTR [edx+48], eax

; 810  :             state->mode = TYPE;

  00747	c7 01 0b 00 00
	00		 mov	 DWORD PTR [ecx], 11	; 0000000bH

; 811  :             break;

  0074d	e9 b7 03 00 00	 jmp	 $LN853@inflate
$LN333@inflate:

; 812  : #endif
; 813  :         case DICTID:
; 814  :             NEEDBITS(32);

  00752	83 fe 20	 cmp	 esi, 32			; 00000020H
  00755	73 24		 jae	 SHORT $LN332@inflate
$LL330@inflate:
  00757	85 db		 test	 ebx, ebx
  00759	0f 84 1b fe ff
	ff		 je	 $LN852@inflate
  0075f	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  00762	8b ce		 mov	 ecx, esi
  00764	d3 e0		 shl	 eax, cl
  00766	4b		 dec	 ebx
  00767	03 d0		 add	 edx, eax
  00769	89 5d f4	 mov	 DWORD PTR _have$1$[ebp], ebx
  0076c	47		 inc	 edi
  0076d	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  00770	83 c6 08	 add	 esi, 8
  00773	89 7d f0	 mov	 DWORD PTR _next$1$[ebp], edi
  00776	83 fe 20	 cmp	 esi, 32			; 00000020H
  00779	72 dc		 jb	 SHORT $LL330@inflate
$LN332@inflate:

; 815  :             strm->adler = state->check = ZSWAP32(hold);

  0077b	8b ca		 mov	 ecx, edx
  0077d	8b c2		 mov	 eax, edx
  0077f	c1 e0 10	 shl	 eax, 16			; 00000010H
  00782	81 e1 00 ff 00
	00		 and	 ecx, 65280		; 0000ff00H
  00788	03 c8		 add	 ecx, eax
  0078a	8b c2		 mov	 eax, edx
  0078c	c1 e8 08	 shr	 eax, 8
  0078f	c1 e1 08	 shl	 ecx, 8
  00792	25 00 ff 00 00	 and	 eax, 65280		; 0000ff00H
  00797	c1 ea 18	 shr	 edx, 24			; 00000018H
  0079a	03 c1		 add	 eax, ecx
  0079c	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  0079f	03 c2		 add	 eax, edx
  007a1	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  007a4	89 41 18	 mov	 DWORD PTR [ecx+24], eax
  007a7	89 42 30	 mov	 DWORD PTR [edx+48], eax

; 816  :             INITBITS();

  007aa	33 d2		 xor	 edx, edx
  007ac	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  007af	33 f6		 xor	 esi, esi

; 817  :             state->mode = DICT;

  007b1	c7 01 0a 00 00
	00		 mov	 DWORD PTR [ecx], 10	; 0000000aH
$LN321@inflate:

; 818  :         case DICT:
; 819  :             if (state->havedict == 0) {

  007b7	83 79 0c 00	 cmp	 DWORD PTR [ecx+12], 0
  007bb	0f 84 53 0d 00
	00		 je	 $LN579@inflate

; 822  :             }
; 823  :             strm->adler = state->check = adler32(0L, Z_NULL, 0);

  007c1	6a 00		 push	 0
  007c3	6a 00		 push	 0
  007c5	6a 00		 push	 0
  007c7	e8 00 00 00 00	 call	 _adler32@12
  007cc	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  007cf	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  007d2	89 41 18	 mov	 DWORD PTR [ecx+24], eax
  007d5	89 42 30	 mov	 DWORD PTR [edx+48], eax
  007d8	8b 55 fc	 mov	 edx, DWORD PTR _hold$1$[ebp]

; 824  :             state->mode = TYPE;

  007db	c7 01 0b 00 00
	00		 mov	 DWORD PTR [ecx], 11	; 0000000bH
$LN316@inflate:

; 825  :         case TYPE:
; 826  :             if (flush == Z_BLOCK || flush == Z_TREES) goto inf_leave;

  007e1	8b 45 0c	 mov	 eax, DWORD PTR _flush$[ebp]
  007e4	83 f8 05	 cmp	 eax, 5
  007e7	0f 84 8d fd ff
	ff		 je	 $LN852@inflate
  007ed	83 f8 06	 cmp	 eax, 6
  007f0	0f 84 84 fd ff
	ff		 je	 $LN852@inflate
$LN315@inflate:

; 827  :         case TYPEDO:
; 828  :             if (state->last) {

  007f6	83 79 04 00	 cmp	 DWORD PTR [ecx+4], 0
  007fa	74 1d		 je	 SHORT $LN308@inflate

; 829  :                 BYTEBITS();

  007fc	8b ce		 mov	 ecx, esi
  007fe	83 e1 07	 and	 ecx, 7
  00801	d3 ea		 shr	 edx, cl
  00803	2b f1		 sub	 esi, ecx

; 830  :                 state->mode = CHECK;

  00805	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  00808	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  0080b	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi
  0080e	c7 01 1a 00 00
	00		 mov	 DWORD PTR [ecx], 26	; 0000001aH

; 831  :                 break;

  00814	e9 f3 02 00 00	 jmp	 $LN490@inflate
$LN308@inflate:

; 832  :             }
; 833  :             NEEDBITS(3);

  00819	83 fe 03	 cmp	 esi, 3
  0081c	73 29		 jae	 SHORT $LN307@inflate
  0081e	8b ff		 npad	 2
$LL305@inflate:
  00820	85 db		 test	 ebx, ebx
  00822	0f 84 52 fd ff
	ff		 je	 $LN852@inflate
  00828	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  0082b	8b ce		 mov	 ecx, esi
  0082d	d3 e0		 shl	 eax, cl
  0082f	4b		 dec	 ebx
  00830	03 d0		 add	 edx, eax
  00832	89 5d f4	 mov	 DWORD PTR _have$1$[ebp], ebx
  00835	47		 inc	 edi
  00836	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  00839	83 c6 08	 add	 esi, 8
  0083c	89 7d f0	 mov	 DWORD PTR _next$1$[ebp], edi
  0083f	83 fe 03	 cmp	 esi, 3
  00842	72 dc		 jb	 SHORT $LL305@inflate
  00844	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
$LN307@inflate:

; 834  :             state->last = BITS(1);

  00847	8b c2		 mov	 eax, edx

; 835  :             DROPBITS(1);

  00849	d1 ea		 shr	 edx, 1
  0084b	83 e0 01	 and	 eax, 1
  0084e	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 836  :             switch (BITS(2)) {

  00851	8b c2		 mov	 eax, edx
  00853	83 e0 03	 and	 eax, 3
  00856	83 f8 03	 cmp	 eax, 3
  00859	77 64		 ja	 SHORT $LN286@inflate
  0085b	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN902@inflate[eax*4]
$LN294@inflate:

; 860  :             }
; 861  :             DROPBITS(2);

  00862	c1 ea 02	 shr	 edx, 2
  00865	83 ee 03	 sub	 esi, 3
  00868	c7 01 0d 00 00
	00		 mov	 DWORD PTR [ecx], 13	; 0000000dH
  0086e	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  00871	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi

; 862  :             break;

  00874	e9 93 02 00 00	 jmp	 $LN490@inflate
$LN293@inflate:

; 837  :             case 0:                             /* stored block */
; 838  :                 Tracev((stderr, "inflate:     stored block%s\n",
; 839  :                         state->last ? " (last)" : ""));
; 840  :                 state->mode = STORED;
; 841  :                 break;
; 842  :             case 1:                             /* fixed block */
; 843  :                 fixedtables(state);

  00879	e8 00 00 00 00	 call	 _fixedtables

; 844  :                 Tracev((stderr, "inflate:     fixed codes block%s\n",
; 845  :                         state->last ? " (last)" : ""));
; 846  :                 state->mode = LEN_;             /* decode codes */
; 847  :                 if (flush == Z_TREES) {

  0087e	83 7d 0c 06	 cmp	 DWORD PTR _flush$[ebp], 6
  00882	c7 01 13 00 00
	00		 mov	 DWORD PTR [ecx], 19	; 00000013H
  00888	75 35		 jne	 SHORT $LN286@inflate

; 848  :                     DROPBITS(2);

  0088a	c1 ea 02	 shr	 edx, 2
  0088d	83 ee 03	 sub	 esi, 3
  00890	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx

; 849  :                     goto inf_leave;

  00893	e9 e2 fc ff ff	 jmp	 $LN852@inflate
$LN288@inflate:

; 860  :             }
; 861  :             DROPBITS(2);

  00898	c1 ea 02	 shr	 edx, 2
  0089b	83 ee 03	 sub	 esi, 3
  0089e	c7 01 10 00 00
	00		 mov	 DWORD PTR [ecx], 16	; 00000010H
  008a4	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  008a7	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi

; 862  :             break;

  008aa	e9 5d 02 00 00	 jmp	 $LN490@inflate
$LN287@inflate:

; 850  :                 }
; 851  :                 break;
; 852  :             case 2:                             /* dynamic block */
; 853  :                 Tracev((stderr, "inflate:     dynamic codes block%s\n",
; 854  :                         state->last ? " (last)" : ""));
; 855  :                 state->mode = TABLE;
; 856  :                 break;
; 857  :             case 3:
; 858  :                 strm->msg = (char *)"invalid block type";

  008af	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  008b2	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BD@PJCBIDD@invalid?5block?5type?$AA@

; 859  :                 state->mode = BAD;

  008b9	c7 01 1d 00 00
	00		 mov	 DWORD PTR [ecx], 29	; 0000001dH
$LN286@inflate:

; 860  :             }
; 861  :             DROPBITS(2);

  008bf	c1 ea 02	 shr	 edx, 2
  008c2	83 ee 03	 sub	 esi, 3
  008c5	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  008c8	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi

; 862  :             break;

  008cb	e9 3c 02 00 00	 jmp	 $LN490@inflate
$LN282@inflate:

; 863  :         case STORED:
; 864  :             BYTEBITS();                         /* go to byte boundary */

  008d0	8b ce		 mov	 ecx, esi
  008d2	83 e1 07	 and	 ecx, 7
  008d5	2b f1		 sub	 esi, ecx
  008d7	d3 ea		 shr	 edx, cl
  008d9	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  008dc	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi

; 865  :             NEEDBITS(32);

  008df	83 fe 20	 cmp	 esi, 32			; 00000020H
  008e2	73 27		 jae	 SHORT $LN278@inflate
$LL276@inflate:
  008e4	85 db		 test	 ebx, ebx
  008e6	0f 84 8e fc ff
	ff		 je	 $LN852@inflate
  008ec	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  008ef	8b ce		 mov	 ecx, esi
  008f1	d3 e0		 shl	 eax, cl
  008f3	83 c6 08	 add	 esi, 8
  008f6	4b		 dec	 ebx
  008f7	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi
  008fa	03 d0		 add	 edx, eax
  008fc	89 5d f4	 mov	 DWORD PTR _have$1$[ebp], ebx
  008ff	47		 inc	 edi
  00900	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  00903	89 7d f0	 mov	 DWORD PTR _next$1$[ebp], edi
  00906	83 fe 20	 cmp	 esi, 32			; 00000020H
  00909	72 d9		 jb	 SHORT $LL276@inflate
$LN278@inflate:

; 866  :             if ((hold & 0xffff) != ((hold >> 16) ^ 0xffff)) {

  0090b	8b c2		 mov	 eax, edx
  0090d	8b ca		 mov	 ecx, edx
  0090f	81 e1 ff ff 00
	00		 and	 ecx, 65535		; 0000ffffH
  00915	f7 d0		 not	 eax
  00917	c1 e8 10	 shr	 eax, 16			; 00000010H
  0091a	89 4d c8	 mov	 DWORD PTR tv2676[ebp], ecx
  0091d	3b c8		 cmp	 ecx, eax

; 868  :                 state->mode = BAD;

  0091f	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  00922	74 15		 je	 SHORT $LN270@inflate

; 867  :                 strm->msg = (char *)"invalid stored block lengths";

  00924	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00927	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BN@LGAADGOK@invalid?5stored?5block?5lengths?$AA@
  0092e	c7 01 1d 00 00
	00		 mov	 DWORD PTR [ecx], 29	; 0000001dH
  00934	e9 d3 01 00 00	 jmp	 $LN490@inflate
$LN270@inflate:

; 869  :                 break;
; 870  :             }
; 871  :             state->length = (unsigned)hold & 0xffff;

  00939	8b 45 c8	 mov	 eax, DWORD PTR tv2676[ebp]

; 872  :             Tracev((stderr, "inflate:       stored length %u\n",
; 873  :                     state->length));
; 874  :             INITBITS();

  0093c	33 d2		 xor	 edx, edx
  0093e	33 f6		 xor	 esi, esi
  00940	89 41 40	 mov	 DWORD PTR [ecx+64], eax

; 875  :             state->mode = COPY_;
; 876  :             if (flush == Z_TREES) goto inf_leave;

  00943	83 7d 0c 06	 cmp	 DWORD PTR _flush$[ebp], 6
  00947	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  0094a	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi
  0094d	c7 01 0e 00 00
	00		 mov	 DWORD PTR [ecx], 14	; 0000000eH
  00953	0f 84 21 fc ff
	ff		 je	 $LN852@inflate
$LN266@inflate:

; 877  :         case COPY_:
; 878  :             state->mode = COPY;

  00959	c7 01 0f 00 00
	00		 mov	 DWORD PTR [ecx], 15	; 0000000fH
$LN264@inflate:

; 879  :         case COPY:
; 880  :             copy = state->length;

  0095f	8b 41 40	 mov	 eax, DWORD PTR [ecx+64]

; 881  :             if (copy) {

  00962	85 c0		 test	 eax, eax
  00964	0f 84 e9 06 00
	00		 je	 $LN263@inflate

; 882  :                 if (copy > have) copy = have;

  0096a	3b c3		 cmp	 eax, ebx
  0096c	0f 47 c3	 cmova	 eax, ebx

; 883  :                 if (copy > left) copy = left;

  0096f	3b 45 e8	 cmp	 eax, DWORD PTR _left$1$[ebp]
  00972	0f 47 45 e8	 cmova	 eax, DWORD PTR _left$1$[ebp]
  00976	89 45 c8	 mov	 DWORD PTR _copy$7$[ebp], eax

; 884  :                 if (copy == 0) goto inf_leave;

  00979	85 c0		 test	 eax, eax
  0097b	0f 84 f9 fb ff
	ff		 je	 $LN852@inflate

; 885  :                 zmemcpy(put, next, copy);

  00981	50		 push	 eax
  00982	57		 push	 edi
  00983	ff 75 e0	 push	 DWORD PTR _put$1$[ebp]
  00986	e8 00 00 00 00	 call	 _memcpy

; 886  :                 have -= copy;

  0098b	8b 45 c8	 mov	 eax, DWORD PTR _copy$7$[ebp]
  0098e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 887  :                 next += copy;
; 888  :                 left -= copy;
; 889  :                 put += copy;
; 890  :                 state->length -= copy;

  00991	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  00994	2b d8		 sub	 ebx, eax
  00996	29 45 e8	 sub	 DWORD PTR _left$1$[ebp], eax
  00999	03 f8		 add	 edi, eax
  0099b	01 45 e0	 add	 DWORD PTR _put$1$[ebp], eax
  0099e	89 5d f4	 mov	 DWORD PTR _have$1$[ebp], ebx
  009a1	29 41 40	 sub	 DWORD PTR [ecx+64], eax
  009a4	89 7d f0	 mov	 DWORD PTR _next$1$[ebp], edi

; 891  :                 break;

  009a7	e9 5d 01 00 00	 jmp	 $LN853@inflate
$LN258@inflate:

; 892  :             }
; 893  :             Tracev((stderr, "inflate:       stored end\n"));
; 894  :             state->mode = TYPE;
; 895  :             break;
; 896  :         case TABLE:
; 897  :             NEEDBITS(14);

  009ac	83 fe 0e	 cmp	 esi, 14			; 0000000eH
  009af	73 27		 jae	 SHORT $LN257@inflate
$LL255@inflate:
  009b1	85 db		 test	 ebx, ebx
  009b3	0f 84 c1 fb ff
	ff		 je	 $LN852@inflate
  009b9	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  009bc	8b ce		 mov	 ecx, esi
  009be	d3 e0		 shl	 eax, cl
  009c0	4b		 dec	 ebx
  009c1	03 d0		 add	 edx, eax
  009c3	89 5d f4	 mov	 DWORD PTR _have$1$[ebp], ebx
  009c6	47		 inc	 edi
  009c7	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  009ca	83 c6 08	 add	 esi, 8
  009cd	89 7d f0	 mov	 DWORD PTR _next$1$[ebp], edi
  009d0	83 fe 0e	 cmp	 esi, 14			; 0000000eH
  009d3	72 dc		 jb	 SHORT $LL255@inflate
  009d5	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
$LN257@inflate:

; 898  :             state->nlen = BITS(5) + 257;

  009d8	8b c2		 mov	 eax, edx

; 899  :             DROPBITS(5);
; 900  :             state->ndist = BITS(5) + 1;
; 901  :             DROPBITS(5);
; 902  :             state->ncode = BITS(4) + 4;
; 903  :             DROPBITS(4);

  009da	83 ee 0e	 sub	 esi, 14			; 0000000eH
  009dd	83 e0 1f	 and	 eax, 31			; 0000001fH
  009e0	c1 ea 05	 shr	 edx, 5
  009e3	05 01 01 00 00	 add	 eax, 257		; 00000101H
  009e8	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi
  009eb	89 41 60	 mov	 DWORD PTR [ecx+96], eax
  009ee	8b c2		 mov	 eax, edx
  009f0	83 e0 1f	 and	 eax, 31			; 0000001fH
  009f3	c1 ea 05	 shr	 edx, 5
  009f6	40		 inc	 eax
  009f7	89 41 64	 mov	 DWORD PTR [ecx+100], eax
  009fa	8b c2		 mov	 eax, edx
  009fc	83 e0 0f	 and	 eax, 15			; 0000000fH
  009ff	c1 ea 04	 shr	 edx, 4
  00a02	83 c0 04	 add	 eax, 4
  00a05	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx

; 904  : #ifndef PKZIP_BUG_WORKAROUND
; 905  :             if (state->nlen > 286 || state->ndist > 30) {

  00a08	81 79 60 1e 01
	00 00		 cmp	 DWORD PTR [ecx+96], 286	; 0000011eH
  00a0f	89 41 5c	 mov	 DWORD PTR [ecx+92], eax
  00a12	0f 87 0d 01 00
	00		 ja	 $LN239@inflate
  00a18	83 79 64 1e	 cmp	 DWORD PTR [ecx+100], 30	; 0000001eH
  00a1c	0f 87 03 01 00
	00		 ja	 $LN239@inflate

; 907  :                 state->mode = BAD;
; 908  :                 break;
; 909  :             }
; 910  : #endif
; 911  :             Tracev((stderr, "inflate:       table sizes ok\n"));
; 912  :             state->have = 0;

  00a22	c7 41 68 00 00
	00 00		 mov	 DWORD PTR [ecx+104], 0

; 913  :             state->mode = LENLENS;

  00a29	c7 01 11 00 00
	00		 mov	 DWORD PTR [ecx], 17	; 00000011H
$LN525@inflate:

; 914  :         case LENLENS:
; 915  :             while (state->have < state->ncode) {

  00a2f	8b 41 68	 mov	 eax, DWORD PTR [ecx+104]
  00a32	3b 41 5c	 cmp	 eax, DWORD PTR [ecx+92]
  00a35	73 64		 jae	 SHORT $LN527@inflate
$LL237@inflate:

; 916  :                 NEEDBITS(3);

  00a37	83 fe 03	 cmp	 esi, 3
  00a3a	73 28		 jae	 SHORT $LN234@inflate
  00a3c	8d 64 24 00	 npad	 4
$LL232@inflate:
  00a40	85 db		 test	 ebx, ebx
  00a42	0f 84 32 fb ff
	ff		 je	 $LN852@inflate
  00a48	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  00a4b	8b ce		 mov	 ecx, esi
  00a4d	d3 e0		 shl	 eax, cl
  00a4f	4b		 dec	 ebx
  00a50	03 d0		 add	 edx, eax
  00a52	89 5d f4	 mov	 DWORD PTR _have$1$[ebp], ebx
  00a55	47		 inc	 edi
  00a56	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  00a59	83 c6 08	 add	 esi, 8
  00a5c	89 7d f0	 mov	 DWORD PTR _next$1$[ebp], edi
  00a5f	83 fe 03	 cmp	 esi, 3
  00a62	72 dc		 jb	 SHORT $LL232@inflate
$LN234@inflate:

; 917  :                 state->lens[order[state->have++]] = (unsigned short)BITS(3);

  00a64	8b 45 f8	 mov	 eax, DWORD PTR _state$1$[ebp]
  00a67	8b ca		 mov	 ecx, edx
  00a69	8b 7d f8	 mov	 edi, DWORD PTR _state$1$[ebp]
  00a6c	83 e1 07	 and	 ecx, 7

; 918  :                 DROPBITS(3);

  00a6f	c1 ea 03	 shr	 edx, 3
  00a72	83 ee 03	 sub	 esi, 3
  00a75	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  00a78	8b 40 68	 mov	 eax, DWORD PTR [eax+104]
  00a7b	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi
  00a7e	0f b7 04 45 00
	00 00 00	 movzx	 eax, WORD PTR ?order@?1??inflate@@9@9[eax*2]
  00a86	66 89 4c 47 70	 mov	 WORD PTR [edi+eax*2+112], cx
  00a8b	8b cf		 mov	 ecx, edi
  00a8d	8b 7d f0	 mov	 edi, DWORD PTR _next$1$[ebp]
  00a90	ff 41 68	 inc	 DWORD PTR [ecx+104]
  00a93	8b 41 68	 mov	 eax, DWORD PTR [ecx+104]
  00a96	3b 41 5c	 cmp	 eax, DWORD PTR [ecx+92]
  00a99	72 9c		 jb	 SHORT $LL237@inflate
$LN527@inflate:

; 919  :             }
; 920  :             while (state->have < 19)

  00a9b	83 79 68 13	 cmp	 DWORD PTR [ecx+104], 19	; 00000013H
  00a9f	73 1b		 jae	 SHORT $LN222@inflate
$LL223@inflate:

; 921  :                 state->lens[order[state->have++]] = 0;

  00aa1	8b 41 68	 mov	 eax, DWORD PTR [ecx+104]
  00aa4	33 d2		 xor	 edx, edx
  00aa6	0f b7 04 45 00
	00 00 00	 movzx	 eax, WORD PTR ?order@?1??inflate@@9@9[eax*2]
  00aae	66 89 54 41 70	 mov	 WORD PTR [ecx+eax*2+112], dx
  00ab3	ff 41 68	 inc	 DWORD PTR [ecx+104]
  00ab6	83 79 68 13	 cmp	 DWORD PTR [ecx+104], 19	; 00000013H
  00aba	72 e5		 jb	 SHORT $LL223@inflate
$LN222@inflate:

; 922  :             state->next = state->codes;
; 923  :             state->lencode = (code const FAR *)(state->next);

  00abc	8b 55 f8	 mov	 edx, DWORD PTR _state$1$[ebp]
  00abf	8d 81 30 05 00
	00		 lea	 eax, DWORD PTR [ecx+1328]
  00ac5	83 c1 6c	 add	 ecx, 108		; 0000006cH
  00ac8	89 42 4c	 mov	 DWORD PTR [edx+76], eax
  00acb	89 01		 mov	 DWORD PTR [ecx], eax

; 924  :             state->lenbits = 7;
; 925  :             ret = inflate_table(CODES, state->lens, 19, &(state->next),
; 926  :                                 &(state->lenbits), state->work);

  00acd	8d 82 f0 02 00
	00		 lea	 eax, DWORD PTR [edx+752]
  00ad3	50		 push	 eax
  00ad4	8d 42 54	 lea	 eax, DWORD PTR [edx+84]
  00ad7	c7 42 54 07 00
	00 00		 mov	 DWORD PTR [edx+84], 7
  00ade	50		 push	 eax
  00adf	51		 push	 ecx
  00ae0	6a 13		 push	 19			; 00000013H
  00ae2	83 c2 70	 add	 edx, 112		; 00000070H
  00ae5	33 c9		 xor	 ecx, ecx
  00ae7	e8 00 00 00 00	 call	 _inflate_table

; 929  :                 state->mode = BAD;

  00aec	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  00aef	83 c4 10	 add	 esp, 16			; 00000010H
  00af2	89 45 d4	 mov	 DWORD PTR _ret$1$[ebp], eax
  00af5	85 c0		 test	 eax, eax
  00af7	74 3e		 je	 SHORT $LN221@inflate

; 927  :             if (ret) {
; 928  :                 strm->msg = (char *)"invalid code lengths set";

  00af9	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00afc	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BJ@HDEPPGOH@invalid?5code?5lengths?5set?$AA@
$LN897@inflate:

; 989  :                 state->mode = BAD;

  00b03	c7 01 1d 00 00
	00		 mov	 DWORD PTR [ecx], 29	; 0000001dH
$LN853@inflate:
  00b09	8b 55 fc	 mov	 edx, DWORD PTR _hold$1$[ebp]
$LN490@inflate:

; 637  :     for (;;)
; 638  :         switch (state->mode) {

  00b0c	8b 01		 mov	 eax, DWORD PTR [ecx]
  00b0e	83 f8 1e	 cmp	 eax, 30			; 0000001eH
  00b11	0f 86 7a f5 ff
	ff		 jbe	 $LL493@inflate
$LN12@inflate:
  00b17	5f		 pop	 edi
  00b18	5e		 pop	 esi

; 1215 :             goto inf_leave;
; 1216 :         case MEM:
; 1217 :             return Z_MEM_ERROR;
; 1218 :         case SYNC:
; 1219 :         default:
; 1220 :             return Z_STREAM_ERROR;

  00b19	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  00b1e	5b		 pop	 ebx

; 1249 :         ret = Z_BUF_ERROR;
; 1250 :     return ret;
; 1251 : }

  00b1f	8b e5		 mov	 esp, ebp
  00b21	5d		 pop	 ebp
  00b22	c2 08 00	 ret	 8
$LN239@inflate:

; 906  :                 strm->msg = (char *)"too many length or distance symbols";

  00b25	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00b28	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0CE@GMIGFPBB@too?5many?5length?5or?5distance?5symb@
  00b2f	c7 01 1d 00 00
	00		 mov	 DWORD PTR [ecx], 29	; 0000001dH
  00b35	eb d5		 jmp	 SHORT $LN490@inflate
$LN221@inflate:

; 930  :                 break;
; 931  :             }
; 932  :             Tracev((stderr, "inflate:       code lengths ok\n"));
; 933  :             state->have = 0;

  00b37	c7 41 68 00 00
	00 00		 mov	 DWORD PTR [ecx+104], 0

; 934  :             state->mode = CODELENS;

  00b3e	c7 01 12 00 00
	00		 mov	 DWORD PTR [ecx], 18	; 00000012H
$LN528@inflate:

; 935  :         case CODELENS:
; 936  :             while (state->have < state->nlen + state->ndist) {

  00b44	8b 41 64	 mov	 eax, DWORD PTR [ecx+100]
  00b47	8b 51 68	 mov	 edx, DWORD PTR [ecx+104]
  00b4a	03 41 60	 add	 eax, DWORD PTR [ecx+96]
  00b4d	89 55 d8	 mov	 DWORD PTR tv2668[ebp], edx
  00b50	3b d0		 cmp	 edx, eax
  00b52	0f 83 10 02 00
	00		 jae	 $LN218@inflate
  00b58	eb 06 8d 9b 00
	00 00 00	 npad	 8
$LL219@inflate:

; 937  :                 for (;;) {
; 938  :                     here = state->lencode[BITS(state->lenbits)];

  00b60	8b 45 d0	 mov	 eax, DWORD PTR tv2752[ebp]
  00b63	ba 01 00 00 00	 mov	 edx, 1
  00b68	8b 08		 mov	 ecx, DWORD PTR [eax]
  00b6a	8b 45 f8	 mov	 eax, DWORD PTR _state$1$[ebp]
  00b6d	d3 e2		 shl	 edx, cl
  00b6f	4a		 dec	 edx
  00b70	23 55 fc	 and	 edx, DWORD PTR _hold$1$[ebp]
  00b73	8b 40 4c	 mov	 eax, DWORD PTR [eax+76]
  00b76	8b 04 90	 mov	 eax, DWORD PTR [eax+edx*4]

; 939  :                     if ((unsigned)(here.bits) <= bits) break;

  00b79	8b c8		 mov	 ecx, eax
  00b7b	c1 e9 08	 shr	 ecx, 8
  00b7e	0f b6 c9	 movzx	 ecx, cl
  00b81	89 45 c8	 mov	 DWORD PTR _here$[ebp], eax
  00b84	3b ce		 cmp	 ecx, esi
  00b86	76 45		 jbe	 SHORT $LN555@inflate
$LL217@inflate:

; 940  :                     PULLBYTE();

  00b88	85 db		 test	 ebx, ebx
  00b8a	0f 84 ea f9 ff
	ff		 je	 $LN852@inflate
  00b90	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  00b93	8b ce		 mov	 ecx, esi
  00b95	d3 e0		 shl	 eax, cl
  00b97	ba 01 00 00 00	 mov	 edx, 1
  00b9c	01 45 fc	 add	 DWORD PTR _hold$1$[ebp], eax
  00b9f	4b		 dec	 ebx
  00ba0	8b 45 d0	 mov	 eax, DWORD PTR tv2752[ebp]
  00ba3	47		 inc	 edi
  00ba4	83 c6 08	 add	 esi, 8
  00ba7	89 5d f4	 mov	 DWORD PTR _have$1$[ebp], ebx
  00baa	89 7d f0	 mov	 DWORD PTR _next$1$[ebp], edi
  00bad	8b 08		 mov	 ecx, DWORD PTR [eax]
  00baf	8b 45 f8	 mov	 eax, DWORD PTR _state$1$[ebp]
  00bb2	d3 e2		 shl	 edx, cl
  00bb4	4a		 dec	 edx
  00bb5	23 55 fc	 and	 edx, DWORD PTR _hold$1$[ebp]
  00bb8	8b 40 4c	 mov	 eax, DWORD PTR [eax+76]
  00bbb	8b 04 90	 mov	 eax, DWORD PTR [eax+edx*4]
  00bbe	8b c8		 mov	 ecx, eax
  00bc0	c1 e9 08	 shr	 ecx, 8
  00bc3	0f b6 c9	 movzx	 ecx, cl
  00bc6	89 45 c8	 mov	 DWORD PTR _here$[ebp], eax
  00bc9	3b ce		 cmp	 ecx, esi
  00bcb	77 bb		 ja	 SHORT $LL217@inflate
$LN555@inflate:

; 941  :                 }
; 942  :                 if (here.val < 16) {

  00bcd	8b d0		 mov	 edx, eax
  00bcf	c1 ea 10	 shr	 edx, 16			; 00000010H
  00bd2	66 83 fa 10	 cmp	 dx, 16			; 00000010H
  00bd6	73 21		 jae	 SHORT $LN894@inflate

; 943  :                     DROPBITS(here.bits);

  00bd8	c1 e8 08	 shr	 eax, 8
  00bdb	0f b6 c8	 movzx	 ecx, al
  00bde	d3 6d fc	 shr	 DWORD PTR _hold$1$[ebp], cl
  00be1	2b f1		 sub	 esi, ecx

; 944  :                     state->lens[state->have++] = here.val;

  00be3	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  00be6	8b 45 d8	 mov	 eax, DWORD PTR tv2668[ebp]
  00be9	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi
  00bec	66 89 54 41 70	 mov	 WORD PTR [ecx+eax*2+112], dx
  00bf1	ff 41 68	 inc	 DWORD PTR [ecx+104]

; 945  :                 }
; 946  :                 else {

  00bf4	e9 5b 01 00 00	 jmp	 $LN603@inflate
$LN894@inflate:

; 947  :                     if (here.val == 16) {

  00bf9	75 70		 jne	 SHORT $LN205@inflate

; 948  :                         NEEDBITS(here.bits + 2);

  00bfb	8b c8		 mov	 ecx, eax
  00bfd	c1 e9 08	 shr	 ecx, 8
  00c00	0f b6 c9	 movzx	 ecx, cl
  00c03	83 c1 02	 add	 ecx, 2
  00c06	89 4d c8	 mov	 DWORD PTR $T1[ebp], ecx
  00c09	3b f1		 cmp	 esi, ecx
  00c0b	73 25		 jae	 SHORT $LN203@inflate
  00c0d	8d 49 00	 npad	 3
$LL201@inflate:
  00c10	85 db		 test	 ebx, ebx
  00c12	0f 84 62 f9 ff
	ff		 je	 $LN852@inflate
  00c18	0f b6 17	 movzx	 edx, BYTE PTR [edi]
  00c1b	8b ce		 mov	 ecx, esi
  00c1d	d3 e2		 shl	 edx, cl
  00c1f	4b		 dec	 ebx
  00c20	01 55 fc	 add	 DWORD PTR _hold$1$[ebp], edx
  00c23	47		 inc	 edi
  00c24	83 c6 08	 add	 esi, 8
  00c27	89 5d f4	 mov	 DWORD PTR _have$1$[ebp], ebx
  00c2a	89 7d f0	 mov	 DWORD PTR _next$1$[ebp], edi
  00c2d	3b 75 c8	 cmp	 esi, DWORD PTR $T1[ebp]
  00c30	72 de		 jb	 SHORT $LL201@inflate
$LN203@inflate:

; 949  :                         DROPBITS(here.bits);

  00c32	8b 55 fc	 mov	 edx, DWORD PTR _hold$1$[ebp]
  00c35	0f b6 cc	 movzx	 ecx, ah

; 950  :                         if (state->have == 0) {

  00c38	8b 45 d8	 mov	 eax, DWORD PTR tv2668[ebp]
  00c3b	2b f1		 sub	 esi, ecx
  00c3d	d3 ea		 shr	 edx, cl

; 952  :                             state->mode = BAD;
; 953  :                             break;
; 954  :                         }
; 955  :                         len = state->lens[state->have - 1];

  00c3f	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  00c42	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  00c45	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi
  00c48	85 c0		 test	 eax, eax
  00c4a	0f 84 3a 01 00
	00		 je	 $LN560@inflate
  00c50	0f b7 44 41 6e	 movzx	 eax, WORD PTR [ecx+eax*2+110]

; 956  :                         copy = 3 + BITS(2);

  00c55	8b ca		 mov	 ecx, edx
  00c57	83 e1 03	 and	 ecx, 3

; 957  :                         DROPBITS(2);

  00c5a	c1 ea 02	 shr	 edx, 2
  00c5d	83 c1 03	 add	 ecx, 3
  00c60	89 45 c8	 mov	 DWORD PTR _len$5$[ebp], eax
  00c63	83 ee 02	 sub	 esi, 2

; 958  :                     }
; 959  :                     else if (here.val == 17) {

  00c66	e9 ac 00 00 00	 jmp	 $LN895@inflate
$LN205@inflate:
  00c6b	66 83 7d ca 11	 cmp	 WORD PTR _here$[ebp+2], 17 ; 00000011H
  00c70	8b 55 fc	 mov	 edx, DWORD PTR _hold$1$[ebp]

; 960  :                         NEEDBITS(here.bits + 3);

  00c73	0f b6 cc	 movzx	 ecx, ah
  00c76	75 4a		 jne	 SHORT $LN170@inflate
  00c78	8d 41 03	 lea	 eax, DWORD PTR [ecx+3]
  00c7b	89 4d ec	 mov	 DWORD PTR tv2650[ebp], ecx
  00c7e	3b f0		 cmp	 esi, eax
  00c80	73 29		 jae	 SHORT $LN185@inflate
$LL183@inflate:
  00c82	85 db		 test	 ebx, ebx
  00c84	0f 84 f0 f8 ff
	ff		 je	 $LN852@inflate
  00c8a	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  00c8d	8b ce		 mov	 ecx, esi
  00c8f	d3 e0		 shl	 eax, cl
  00c91	4b		 dec	 ebx
  00c92	8b 4d ec	 mov	 ecx, DWORD PTR tv2650[ebp]
  00c95	03 d0		 add	 edx, eax
  00c97	47		 inc	 edi
  00c98	89 5d f4	 mov	 DWORD PTR _have$1$[ebp], ebx
  00c9b	83 c6 08	 add	 esi, 8
  00c9e	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  00ca1	89 7d f0	 mov	 DWORD PTR _next$1$[ebp], edi
  00ca4	8d 41 03	 lea	 eax, DWORD PTR [ecx+3]
  00ca7	3b f0		 cmp	 esi, eax
  00ca9	72 d7		 jb	 SHORT $LL183@inflate
$LN185@inflate:

; 961  :                         DROPBITS(here.bits);

  00cab	d3 ea		 shr	 edx, cl

; 962  :                         len = 0;
; 963  :                         copy = 3 + BITS(3);
; 964  :                         DROPBITS(3);

  00cad	b8 fd ff ff ff	 mov	 eax, -3			; fffffffdH
  00cb2	8b ca		 mov	 ecx, edx
  00cb4	c1 ea 03	 shr	 edx, 3
  00cb7	83 e1 07	 and	 ecx, 7
  00cba	83 c1 03	 add	 ecx, 3
  00cbd	2b 45 ec	 sub	 eax, DWORD PTR tv2650[ebp]

; 965  :                     }
; 966  :                     else {

  00cc0	eb 4c		 jmp	 SHORT $LN896@inflate
$LN170@inflate:

; 967  :                         NEEDBITS(here.bits + 7);

  00cc2	8d 41 07	 lea	 eax, DWORD PTR [ecx+7]
  00cc5	89 4d ec	 mov	 DWORD PTR tv2649[ebp], ecx
  00cc8	3b f0		 cmp	 esi, eax
  00cca	73 2d		 jae	 SHORT $LN169@inflate
  00ccc	8d 64 24 00	 npad	 4
$LL167@inflate:
  00cd0	85 db		 test	 ebx, ebx
  00cd2	0f 84 a2 f8 ff
	ff		 je	 $LN852@inflate
  00cd8	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  00cdb	8b ce		 mov	 ecx, esi
  00cdd	d3 e0		 shl	 eax, cl
  00cdf	4b		 dec	 ebx
  00ce0	8b 4d ec	 mov	 ecx, DWORD PTR tv2649[ebp]
  00ce3	03 d0		 add	 edx, eax
  00ce5	47		 inc	 edi
  00ce6	89 5d f4	 mov	 DWORD PTR _have$1$[ebp], ebx
  00ce9	83 c6 08	 add	 esi, 8
  00cec	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  00cef	89 7d f0	 mov	 DWORD PTR _next$1$[ebp], edi
  00cf2	8d 41 07	 lea	 eax, DWORD PTR [ecx+7]
  00cf5	3b f0		 cmp	 esi, eax
  00cf7	72 d7		 jb	 SHORT $LL167@inflate
$LN169@inflate:

; 968  :                         DROPBITS(here.bits);

  00cf9	d3 ea		 shr	 edx, cl

; 969  :                         len = 0;
; 970  :                         copy = 11 + BITS(7);
; 971  :                         DROPBITS(7);

  00cfb	b8 f9 ff ff ff	 mov	 eax, -7			; fffffff9H
  00d00	8b ca		 mov	 ecx, edx
  00d02	c1 ea 07	 shr	 edx, 7
  00d05	83 e1 7f	 and	 ecx, 127		; 0000007fH
  00d08	83 c1 0b	 add	 ecx, 11			; 0000000bH
  00d0b	2b 45 ec	 sub	 eax, DWORD PTR tv2649[ebp]
$LN896@inflate:
  00d0e	03 f0		 add	 esi, eax
  00d10	c7 45 c8 00 00
	00 00		 mov	 DWORD PTR _len$5$[ebp], 0
$LN895@inflate:

; 972  :                     }
; 973  :                     if (state->have + copy > state->nlen + state->ndist) {

  00d17	8b 45 f8	 mov	 eax, DWORD PTR _state$1$[ebp]
  00d1a	8b 7d f8	 mov	 edi, DWORD PTR _state$1$[ebp]
  00d1d	89 4d cc	 mov	 DWORD PTR _copy$8$[ebp], ecx
  00d20	03 4d d8	 add	 ecx, DWORD PTR tv2668[ebp]
  00d23	8b 40 64	 mov	 eax, DWORD PTR [eax+100]
  00d26	03 47 60	 add	 eax, DWORD PTR [edi+96]
  00d29	8b 7d f0	 mov	 edi, DWORD PTR _next$1$[ebp]
  00d2c	3b c8		 cmp	 ecx, eax
  00d2e	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  00d31	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  00d34	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi
  00d37	77 51		 ja	 SHORT $LN560@inflate

; 974  :                         strm->msg = (char *)"invalid bit length repeat";
; 975  :                         state->mode = BAD;
; 976  :                         break;
; 977  :                     }
; 978  :                     while (copy--)

  00d39	8b 55 cc	 mov	 edx, DWORD PTR _copy$8$[ebp]
  00d3c	85 d2		 test	 edx, edx
  00d3e	74 14		 je	 SHORT $LN603@inflate
  00d40	8b 5d c8	 mov	 ebx, DWORD PTR _len$5$[ebp]
$LL154@inflate:

; 979  :                         state->lens[state->have++] = (unsigned short)len;

  00d43	8b 41 68	 mov	 eax, DWORD PTR [ecx+104]
  00d46	66 89 5c 41 70	 mov	 WORD PTR [ecx+eax*2+112], bx
  00d4b	ff 41 68	 inc	 DWORD PTR [ecx+104]
  00d4e	4a		 dec	 edx
  00d4f	75 f2		 jne	 SHORT $LL154@inflate
  00d51	8b 5d f4	 mov	 ebx, DWORD PTR _have$1$[ebp]
$LN603@inflate:

; 935  :         case CODELENS:
; 936  :             while (state->have < state->nlen + state->ndist) {

  00d54	8b 41 64	 mov	 eax, DWORD PTR [ecx+100]
  00d57	8b 51 68	 mov	 edx, DWORD PTR [ecx+104]
  00d5a	03 41 60	 add	 eax, DWORD PTR [ecx+96]
  00d5d	89 55 d8	 mov	 DWORD PTR tv2668[ebp], edx
  00d60	3b d0		 cmp	 edx, eax
  00d62	0f 82 f8 fd ff
	ff		 jb	 $LL219@inflate
$LN218@inflate:

; 980  :                 }
; 981  :             }
; 982  : 
; 983  :             /* handle error breaks in while */
; 984  :             if (state->mode == BAD) break;

  00d68	83 39 1d	 cmp	 DWORD PTR [ecx], 29	; 0000001dH
  00d6b	0f 84 98 fd ff
	ff		 je	 $LN853@inflate

; 985  : 
; 986  :             /* check for end-of-block code (better have one) */
; 987  :             if (state->lens[256] == 0) {

  00d71	66 83 b9 70 02
	00 00 00	 cmp	 WORD PTR [ecx+624], 0
  00d79	75 24		 jne	 SHORT $LN151@inflate

; 988  :                 strm->msg = (char *)"invalid code -- missing end-of-block";

  00d7b	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00d7e	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0CF@DGDMADCD@invalid?5code?5?9?9?5missing?5end?9of?9b@

; 990  :                 break;

  00d85	e9 79 fd ff ff	 jmp	 $LN897@inflate
$LN560@inflate:

; 951  :                             strm->msg = (char *)"invalid bit length repeat";

  00d8a	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00d8d	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BK@BMMPFBBH@invalid?5bit?5length?5repeat?$AA@
  00d94	c7 01 1d 00 00
	00		 mov	 DWORD PTR [ecx], 29	; 0000001dH
  00d9a	e9 6d fd ff ff	 jmp	 $LN490@inflate
$LN151@inflate:

; 991  :             }
; 992  : 
; 993  :             /* build code tables -- note: do not change the lenbits or distbits
; 994  :                values here (9 and 6) without reading the comments in inftrees.h
; 995  :                concerning the ENOUGH constants, which depend on those values */
; 996  :             state->next = state->codes;

  00d9f	8d 51 6c	 lea	 edx, DWORD PTR [ecx+108]

; 997  :             state->lencode = (code const FAR *)(state->next);
; 998  :             state->lenbits = 9;

  00da2	c7 41 54 09 00
	00 00		 mov	 DWORD PTR [ecx+84], 9
  00da9	8d 81 30 05 00
	00		 lea	 eax, DWORD PTR [ecx+1328]
  00daf	89 55 c8	 mov	 DWORD PTR tv2662[ebp], edx
  00db2	89 02		 mov	 DWORD PTR [edx], eax
  00db4	89 41 4c	 mov	 DWORD PTR [ecx+76], eax

; 999  :             ret = inflate_table(LENS, state->lens, state->nlen, &(state->next),
; 1000 :                                 &(state->lenbits), state->work);

  00db7	8d 81 f0 02 00
	00		 lea	 eax, DWORD PTR [ecx+752]
  00dbd	50		 push	 eax
  00dbe	8d 41 54	 lea	 eax, DWORD PTR [ecx+84]
  00dc1	50		 push	 eax
  00dc2	52		 push	 edx
  00dc3	ff 71 60	 push	 DWORD PTR [ecx+96]
  00dc6	8d 51 70	 lea	 edx, DWORD PTR [ecx+112]
  00dc9	b9 01 00 00 00	 mov	 ecx, 1
  00dce	e8 00 00 00 00	 call	 _inflate_table

; 1003 :                 state->mode = BAD;

  00dd3	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  00dd6	83 c4 10	 add	 esp, 16			; 00000010H
  00dd9	89 45 d4	 mov	 DWORD PTR _ret$1$[ebp], eax
  00ddc	85 c0		 test	 eax, eax
  00dde	74 0f		 je	 SHORT $LN150@inflate

; 1001 :             if (ret) {
; 1002 :                 strm->msg = (char *)"invalid literal/lengths set";

  00de0	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00de3	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BM@IIMGAINC@invalid?5literal?1lengths?5set?$AA@

; 1004 :                 break;

  00dea	e9 14 fd ff ff	 jmp	 $LN897@inflate
$LN150@inflate:

; 1005 :             }
; 1006 :             state->distcode = (code const FAR *)(state->next);

  00def	8b 55 c8	 mov	 edx, DWORD PTR tv2662[ebp]

; 1007 :             state->distbits = 6;

  00df2	c7 41 58 06 00
	00 00		 mov	 DWORD PTR [ecx+88], 6
  00df9	8b 02		 mov	 eax, DWORD PTR [edx]
  00dfb	89 41 50	 mov	 DWORD PTR [ecx+80], eax

; 1008 :             ret = inflate_table(DISTS, state->lens + state->nlen, state->ndist,
; 1009 :                             &(state->next), &(state->distbits), state->work);

  00dfe	8d 81 f0 02 00
	00		 lea	 eax, DWORD PTR [ecx+752]
  00e04	50		 push	 eax
  00e05	8d 41 58	 lea	 eax, DWORD PTR [ecx+88]
  00e08	50		 push	 eax
  00e09	8b 41 60	 mov	 eax, DWORD PTR [ecx+96]
  00e0c	52		 push	 edx
  00e0d	ff 71 64	 push	 DWORD PTR [ecx+100]
  00e10	83 c1 70	 add	 ecx, 112		; 00000070H
  00e13	8d 14 41	 lea	 edx, DWORD PTR [ecx+eax*2]
  00e16	b9 02 00 00 00	 mov	 ecx, 2
  00e1b	e8 00 00 00 00	 call	 _inflate_table

; 1012 :                 state->mode = BAD;

  00e20	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  00e23	83 c4 10	 add	 esp, 16			; 00000010H
  00e26	89 45 d4	 mov	 DWORD PTR _ret$1$[ebp], eax
  00e29	85 c0		 test	 eax, eax
  00e2b	74 0f		 je	 SHORT $LN149@inflate

; 1010 :             if (ret) {
; 1011 :                 strm->msg = (char *)"invalid distances set";

  00e2d	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00e30	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BG@GMDFCBGP@invalid?5distances?5set?$AA@

; 1013 :                 break;

  00e37	e9 c7 fc ff ff	 jmp	 $LN897@inflate
$LN149@inflate:

; 1014 :             }
; 1015 :             Tracev((stderr, "inflate:       codes ok\n"));
; 1016 :             state->mode = LEN_;
; 1017 :             if (flush == Z_TREES) goto inf_leave;

  00e3c	8b 55 0c	 mov	 edx, DWORD PTR _flush$[ebp]
  00e3f	c7 01 13 00 00
	00		 mov	 DWORD PTR [ecx], 19	; 00000013H
  00e45	83 fa 06	 cmp	 edx, 6
  00e48	0f 84 18 07 00
	00		 je	 $LN828@inflate
  00e4e	8b 55 fc	 mov	 edx, DWORD PTR _hold$1$[ebp]
$LN148@inflate:

; 1018 :         case LEN_:
; 1019 :             state->mode = LEN;

  00e51	c7 01 14 00 00
	00		 mov	 DWORD PTR [ecx], 20	; 00000014H
$LN146@inflate:

; 1020 :         case LEN:
; 1021 :             if (have >= 6 && left >= 258) {

  00e57	83 fb 06	 cmp	 ebx, 6
  00e5a	72 73		 jb	 SHORT $LN145@inflate
  00e5c	81 7d e8 02 01
	00 00		 cmp	 DWORD PTR _left$1$[ebp], 258 ; 00000102H
  00e63	72 6a		 jb	 SHORT $LN145@inflate

; 1022 :                 RESTORE();

  00e65	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00e68	8b 7d e0	 mov	 edi, DWORD PTR _put$1$[ebp]

; 1023 :                 inflate_fast(strm, out);

  00e6b	ff 75 dc	 push	 DWORD PTR _out$1$[ebp]
  00e6e	89 78 0c	 mov	 DWORD PTR [eax+12], edi
  00e71	8b 7d e8	 mov	 edi, DWORD PTR _left$1$[ebp]
  00e74	89 78 10	 mov	 DWORD PTR [eax+16], edi
  00e77	8b 7d f0	 mov	 edi, DWORD PTR _next$1$[ebp]
  00e7a	89 38		 mov	 DWORD PTR [eax], edi
  00e7c	89 58 04	 mov	 DWORD PTR [eax+4], ebx
  00e7f	50		 push	 eax
  00e80	89 51 38	 mov	 DWORD PTR [ecx+56], edx
  00e83	89 71 3c	 mov	 DWORD PTR [ecx+60], esi
  00e86	e8 00 00 00 00	 call	 _inflate_fast

; 1024 :                 LOAD();

  00e8b	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00e8e	83 c4 08	 add	 esp, 8
  00e91	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00e94	8b 38		 mov	 edi, DWORD PTR [eax]
  00e96	8b 58 04	 mov	 ebx, DWORD PTR [eax+4]
  00e99	89 4d e0	 mov	 DWORD PTR _put$1$[ebp], ecx
  00e9c	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00e9f	89 4d e8	 mov	 DWORD PTR _left$1$[ebp], ecx
  00ea2	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  00ea5	89 7d f0	 mov	 DWORD PTR _next$1$[ebp], edi
  00ea8	89 5d f4	 mov	 DWORD PTR _have$1$[ebp], ebx

; 1025 :                 if (state->mode == TYPE)

  00eab	83 39 0b	 cmp	 DWORD PTR [ecx], 11	; 0000000bH
  00eae	8b 51 38	 mov	 edx, DWORD PTR [ecx+56]
  00eb1	8b 71 3c	 mov	 esi, DWORD PTR [ecx+60]
  00eb4	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  00eb7	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi
  00eba	0f 85 4c fc ff
	ff		 jne	 $LN490@inflate

; 1026 :                     state->back = -1;

  00ec0	c7 81 c4 1b 00
	00 ff ff ff ff	 mov	 DWORD PTR [ecx+7108], -1

; 1027 :                 break;

  00eca	e9 3d fc ff ff	 jmp	 $LN490@inflate
$LN145@inflate:

; 1028 :             }
; 1029 :             state->back = 0;
; 1030 :             for (;;) {
; 1031 :                 here = state->lencode[BITS(state->lenbits)];

  00ecf	8b 41 4c	 mov	 eax, DWORD PTR [ecx+76]
  00ed2	c7 81 c4 1b 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+7108], 0
  00edc	8b 4d d0	 mov	 ecx, DWORD PTR tv2752[ebp]
  00edf	89 45 cc	 mov	 DWORD PTR tv2660[ebp], eax
  00ee2	b8 01 00 00 00	 mov	 eax, 1
  00ee7	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00ee9	d3 e0		 shl	 eax, cl
  00eeb	8b 4d cc	 mov	 ecx, DWORD PTR tv2660[ebp]
  00eee	48		 dec	 eax
  00eef	23 c2		 and	 eax, edx
  00ef1	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]

; 1032 :                 if ((unsigned)(here.bits) <= bits) break;

  00ef4	8b c8		 mov	 ecx, eax
  00ef6	c1 e9 08	 shr	 ecx, 8
  00ef9	0f b6 c9	 movzx	 ecx, cl
  00efc	3b ce		 cmp	 ecx, esi
  00efe	76 47		 jbe	 SHORT $LN562@inflate
$LL137@inflate:

; 1033 :                 PULLBYTE();

  00f00	85 db		 test	 ebx, ebx
  00f02	0f 84 72 f6 ff
	ff		 je	 $LN852@inflate
  00f08	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  00f0b	8b ce		 mov	 ecx, esi
  00f0d	d3 e0		 shl	 eax, cl
  00f0f	4b		 dec	 ebx
  00f10	03 d0		 add	 edx, eax
  00f12	89 5d f4	 mov	 DWORD PTR _have$1$[ebp], ebx
  00f15	8b 45 d0	 mov	 eax, DWORD PTR tv2752[ebp]
  00f18	47		 inc	 edi
  00f19	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  00f1c	83 c6 08	 add	 esi, 8
  00f1f	ba 01 00 00 00	 mov	 edx, 1
  00f24	89 7d f0	 mov	 DWORD PTR _next$1$[ebp], edi
  00f27	8b 08		 mov	 ecx, DWORD PTR [eax]
  00f29	8b 45 f8	 mov	 eax, DWORD PTR _state$1$[ebp]
  00f2c	d3 e2		 shl	 edx, cl
  00f2e	4a		 dec	 edx
  00f2f	23 55 fc	 and	 edx, DWORD PTR _hold$1$[ebp]
  00f32	8b 40 4c	 mov	 eax, DWORD PTR [eax+76]
  00f35	8b 04 90	 mov	 eax, DWORD PTR [eax+edx*4]
  00f38	8b c8		 mov	 ecx, eax
  00f3a	8b 55 fc	 mov	 edx, DWORD PTR _hold$1$[ebp]
  00f3d	c1 e9 08	 shr	 ecx, 8
  00f40	0f b6 c9	 movzx	 ecx, cl
  00f43	3b ce		 cmp	 ecx, esi
  00f45	77 b9		 ja	 SHORT $LL137@inflate
$LN562@inflate:

; 1034 :             }
; 1035 :             if (here.op && (here.op & 0xf0) == 0) {

  00f47	84 c0		 test	 al, al
  00f49	0f 84 be 00 00
	00		 je	 $LN119@inflate
  00f4f	a8 f0		 test	 al, 240			; 000000f0H
  00f51	0f 85 b6 00 00
	00		 jne	 $LN119@inflate

; 1036 :                 last = here;
; 1037 :                 for (;;) {
; 1038 :                     here = state->lencode[last.val +
; 1039 :                             (BITS(last.bits + last.op) >> last.bits)];

  00f57	8b c8		 mov	 ecx, eax
  00f59	bb 01 00 00 00	 mov	 ebx, 1
  00f5e	c1 e9 08	 shr	 ecx, 8
  00f61	8b d0		 mov	 edx, eax
  00f63	0f b6 f9	 movzx	 edi, cl
  00f66	89 4d d8	 mov	 DWORD PTR tv2659[ebp], ecx
  00f69	0f b6 c8	 movzx	 ecx, al
  00f6c	03 cf		 add	 ecx, edi
  00f6e	c1 e8 10	 shr	 eax, 16			; 00000010H
  00f71	d3 e3		 shl	 ebx, cl
  00f73	8b cf		 mov	 ecx, edi
  00f75	4b		 dec	 ebx
  00f76	89 55 c8	 mov	 DWORD PTR _last$[ebp], edx
  00f79	23 5d fc	 and	 ebx, DWORD PTR _hold$1$[ebp]
  00f7c	d3 eb		 shr	 ebx, cl
  00f7e	8b 4d cc	 mov	 ecx, DWORD PTR tv2660[ebp]
  00f81	03 d8		 add	 ebx, eax
  00f83	8b 04 99	 mov	 eax, DWORD PTR [ecx+ebx*4]

; 1040 :                     if ((unsigned)(last.bits + here.bits) <= bits) break;

  00f86	8b c8		 mov	 ecx, eax
  00f88	c1 e9 08	 shr	 ecx, 8
  00f8b	0f b6 f9	 movzx	 edi, cl
  00f8e	8b 4d d8	 mov	 ecx, DWORD PTR tv2659[ebp]
  00f91	0f b6 c9	 movzx	 ecx, cl
  00f94	03 f9		 add	 edi, ecx
  00f96	3b fe		 cmp	 edi, esi
  00f98	76 5d		 jbe	 SHORT $LN122@inflate
  00f9a	8d 9b 00 00 00
	00		 npad	 6
$LL129@inflate:

; 1041 :                     PULLBYTE();

  00fa0	8b 45 f4	 mov	 eax, DWORD PTR _have$1$[ebp]
  00fa3	85 c0		 test	 eax, eax
  00fa5	0f 84 d2 f5 ff
	ff		 je	 $LN862@inflate
  00fab	8b 5d f0	 mov	 ebx, DWORD PTR _next$1$[ebp]
  00fae	48		 dec	 eax
  00faf	89 45 f4	 mov	 DWORD PTR _have$1$[ebp], eax
  00fb2	8b ce		 mov	 ecx, esi
  00fb4	bf 01 00 00 00	 mov	 edi, 1
  00fb9	83 c6 08	 add	 esi, 8
  00fbc	0f b6 03	 movzx	 eax, BYTE PTR [ebx]
  00fbf	43		 inc	 ebx
  00fc0	d3 e0		 shl	 eax, cl
  00fc2	01 45 fc	 add	 DWORD PTR _hold$1$[ebp], eax
  00fc5	0f b7 45 ca	 movzx	 eax, WORD PTR _last$[ebp+2]
  00fc9	89 5d f0	 mov	 DWORD PTR _next$1$[ebp], ebx
  00fcc	0f b6 de	 movzx	 ebx, dh
  00fcf	0f b6 ca	 movzx	 ecx, dl
  00fd2	03 cb		 add	 ecx, ebx
  00fd4	d3 e7		 shl	 edi, cl
  00fd6	8b cb		 mov	 ecx, ebx
  00fd8	4f		 dec	 edi
  00fd9	23 7d fc	 and	 edi, DWORD PTR _hold$1$[ebp]
  00fdc	d3 ef		 shr	 edi, cl
  00fde	03 f8		 add	 edi, eax
  00fe0	8b 45 f8	 mov	 eax, DWORD PTR _state$1$[ebp]
  00fe3	8b 40 4c	 mov	 eax, DWORD PTR [eax+76]
  00fe6	8b 04 b8	 mov	 eax, DWORD PTR [eax+edi*4]
  00fe9	8b c8		 mov	 ecx, eax
  00feb	c1 e9 08	 shr	 ecx, 8
  00fee	0f b6 c9	 movzx	 ecx, cl
  00ff1	03 cb		 add	 ecx, ebx
  00ff3	3b ce		 cmp	 ecx, esi
  00ff5	77 a9		 ja	 SHORT $LL129@inflate
$LN122@inflate:

; 1042 :                 }
; 1043 :                 DROPBITS(last.bits);
; 1044 :                 state->back += last.bits;

  00ff7	8b 5d f8	 mov	 ebx, DWORD PTR _state$1$[ebp]
  00ffa	0f b6 ce	 movzx	 ecx, dh
  00ffd	8b 55 fc	 mov	 edx, DWORD PTR _hold$1$[ebp]
  01000	d3 ea		 shr	 edx, cl
  01002	2b f1		 sub	 esi, ecx
  01004	89 8b c4 1b 00
	00		 mov	 DWORD PTR [ebx+7108], ecx
  0100a	8b 5d f4	 mov	 ebx, DWORD PTR _have$1$[ebp]
$LN119@inflate:

; 1045 :             }
; 1046 :             DROPBITS(here.bits);
; 1047 :             state->back += here.bits;

  0100d	8b 7d f8	 mov	 edi, DWORD PTR _state$1$[ebp]
  01010	8b c8		 mov	 ecx, eax
  01012	c1 e9 08	 shr	 ecx, 8
  01015	0f b6 c9	 movzx	 ecx, cl
  01018	d3 ea		 shr	 edx, cl
  0101a	2b f1		 sub	 esi, ecx
  0101c	01 8f c4 1b 00
	00		 add	 DWORD PTR [edi+7108], ecx

; 1048 :             state->length = (unsigned)here.val;

  01022	8b c8		 mov	 ecx, eax
  01024	c1 e9 10	 shr	 ecx, 16			; 00000010H
  01027	89 4f 40	 mov	 DWORD PTR [edi+64], ecx

; 1049 :             if ((int)(here.op) == 0) {

  0102a	8b 7d f0	 mov	 edi, DWORD PTR _next$1$[ebp]

; 1050 :                 Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
; 1051 :                         "inflate:         literal '%c'\n" :
; 1052 :                         "inflate:         literal 0x%02x\n", here.val));
; 1053 :                 state->mode = LIT;

  0102d	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  01030	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  01033	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi
  01036	84 c0		 test	 al, al
  01038	75 0b		 jne	 SHORT $LN116@inflate
  0103a	c7 01 19 00 00
	00		 mov	 DWORD PTR [ecx], 25	; 00000019H

; 1054 :                 break;

  01040	e9 c7 fa ff ff	 jmp	 $LN490@inflate
$LN116@inflate:

; 1055 :             }
; 1056 :             if (here.op & 32) {

  01045	a8 20		 test	 al, 32			; 00000020H
  01047	74 15		 je	 SHORT $LN115@inflate

; 1057 :                 Tracevv((stderr, "inflate:         end of block\n"));
; 1058 :                 state->back = -1;

  01049	c7 81 c4 1b 00
	00 ff ff ff ff	 mov	 DWORD PTR [ecx+7108], -1
$LN263@inflate:

; 1059 :                 state->mode = TYPE;

  01053	c7 01 0b 00 00
	00		 mov	 DWORD PTR [ecx], 11	; 0000000bH

; 1060 :                 break;

  01059	e9 ae fa ff ff	 jmp	 $LN490@inflate
$LN115@inflate:

; 1061 :             }
; 1062 :             if (here.op & 64) {

  0105e	a8 40		 test	 al, 64			; 00000040H
  01060	74 15		 je	 SHORT $LN114@inflate

; 1063 :                 strm->msg = (char *)"invalid literal/length code";

  01062	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  01065	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BM@FFFLPBBC@invalid?5literal?1length?5code?$AA@
  0106c	c7 01 1d 00 00
	00		 mov	 DWORD PTR [ecx], 29	; 0000001dH
  01072	e9 95 fa ff ff	 jmp	 $LN490@inflate
$LN114@inflate:

; 1064 :                 state->mode = BAD;
; 1065 :                 break;
; 1066 :             }
; 1067 :             state->extra = (unsigned)(here.op) & 15;

  01077	0f b6 c0	 movzx	 eax, al
  0107a	83 e0 0f	 and	 eax, 15			; 0000000fH

; 1068 :             state->mode = LENEXT;

  0107d	c7 01 15 00 00
	00		 mov	 DWORD PTR [ecx], 21	; 00000015H
  01083	89 41 48	 mov	 DWORD PTR [ecx+72], eax
$LN113@inflate:

; 1069 :         case LENEXT:
; 1070 :             if (state->extra) {

  01086	8b 41 48	 mov	 eax, DWORD PTR [ecx+72]
  01089	89 45 c8	 mov	 DWORD PTR tv2639[ebp], eax
  0108c	85 c0		 test	 eax, eax
  0108e	74 50		 je	 SHORT $LN112@inflate

; 1071 :                 NEEDBITS(state->extra);

  01090	3b f0		 cmp	 esi, eax
  01092	73 24		 jae	 SHORT $LN110@inflate
$LL108@inflate:
  01094	85 db		 test	 ebx, ebx
  01096	0f 84 de f4 ff
	ff		 je	 $LN852@inflate
  0109c	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  0109f	8b ce		 mov	 ecx, esi
  010a1	d3 e0		 shl	 eax, cl
  010a3	4b		 dec	 ebx
  010a4	03 d0		 add	 edx, eax
  010a6	89 5d f4	 mov	 DWORD PTR _have$1$[ebp], ebx
  010a9	47		 inc	 edi
  010aa	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  010ad	83 c6 08	 add	 esi, 8
  010b0	89 7d f0	 mov	 DWORD PTR _next$1$[ebp], edi
  010b3	3b 75 c8	 cmp	 esi, DWORD PTR tv2639[ebp]
  010b6	72 dc		 jb	 SHORT $LL108@inflate
$LN110@inflate:

; 1072 :                 state->length += BITS(state->extra);

  010b8	8b 4d c8	 mov	 ecx, DWORD PTR tv2639[ebp]
  010bb	b8 01 00 00 00	 mov	 eax, 1
  010c0	d3 e0		 shl	 eax, cl
  010c2	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  010c5	48		 dec	 eax
  010c6	23 c2		 and	 eax, edx
  010c8	01 41 40	 add	 DWORD PTR [ecx+64], eax

; 1073 :                 DROPBITS(state->extra);

  010cb	8b 45 c8	 mov	 eax, DWORD PTR tv2639[ebp]
  010ce	8b c8		 mov	 ecx, eax
  010d0	d3 ea		 shr	 edx, cl
  010d2	2b f0		 sub	 esi, eax

; 1074 :                 state->back += state->extra;

  010d4	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  010d7	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  010da	01 81 c4 1b 00
	00		 add	 DWORD PTR [ecx+7108], eax
$LN112@inflate:

; 1075 :             }
; 1076 :             Tracevv((stderr, "inflate:         length %u\n", state->length));
; 1077 :             state->was = state->length;

  010e0	8b 41 40	 mov	 eax, DWORD PTR [ecx+64]
  010e3	89 81 c8 1b 00
	00		 mov	 DWORD PTR [ecx+7112], eax

; 1078 :             state->mode = DIST;

  010e9	c7 01 16 00 00
	00		 mov	 DWORD PTR [ecx], 22	; 00000016H
$LN537@inflate:

; 1079 :         case DIST:
; 1080 :             for (;;) {
; 1081 :                 here = state->distcode[BITS(state->distbits)];

  010ef	8b 41 50	 mov	 eax, DWORD PTR [ecx+80]
  010f2	8b 4d c0	 mov	 ecx, DWORD PTR tv2749[ebp]
  010f5	89 45 cc	 mov	 DWORD PTR tv2636[ebp], eax
  010f8	b8 01 00 00 00	 mov	 eax, 1
  010fd	8b 09		 mov	 ecx, DWORD PTR [ecx]
  010ff	d3 e0		 shl	 eax, cl
  01101	8b 4d cc	 mov	 ecx, DWORD PTR tv2636[ebp]
  01104	48		 dec	 eax
  01105	23 c2		 and	 eax, edx
  01107	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]

; 1082 :                 if ((unsigned)(here.bits) <= bits) break;

  0110a	8b c8		 mov	 ecx, eax
  0110c	c1 e9 08	 shr	 ecx, 8
  0110f	0f b6 c9	 movzx	 ecx, cl
  01112	3b ce		 cmp	 ecx, esi
  01114	76 47		 jbe	 SHORT $LN567@inflate
$LL98@inflate:

; 1083 :                 PULLBYTE();

  01116	85 db		 test	 ebx, ebx
  01118	0f 84 5c f4 ff
	ff		 je	 $LN852@inflate
  0111e	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  01121	8b ce		 mov	 ecx, esi
  01123	d3 e0		 shl	 eax, cl
  01125	4b		 dec	 ebx
  01126	03 d0		 add	 edx, eax
  01128	89 5d f4	 mov	 DWORD PTR _have$1$[ebp], ebx
  0112b	8b 45 c0	 mov	 eax, DWORD PTR tv2749[ebp]
  0112e	47		 inc	 edi
  0112f	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  01132	83 c6 08	 add	 esi, 8
  01135	ba 01 00 00 00	 mov	 edx, 1
  0113a	89 7d f0	 mov	 DWORD PTR _next$1$[ebp], edi
  0113d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0113f	8b 45 f8	 mov	 eax, DWORD PTR _state$1$[ebp]
  01142	d3 e2		 shl	 edx, cl
  01144	4a		 dec	 edx
  01145	23 55 fc	 and	 edx, DWORD PTR _hold$1$[ebp]
  01148	8b 40 50	 mov	 eax, DWORD PTR [eax+80]
  0114b	8b 04 90	 mov	 eax, DWORD PTR [eax+edx*4]
  0114e	8b c8		 mov	 ecx, eax
  01150	8b 55 fc	 mov	 edx, DWORD PTR _hold$1$[ebp]
  01153	c1 e9 08	 shr	 ecx, 8
  01156	0f b6 c9	 movzx	 ecx, cl
  01159	3b ce		 cmp	 ecx, esi
  0115b	77 b9		 ja	 SHORT $LL98@inflate
$LN567@inflate:

; 1084 :             }
; 1085 :             if ((here.op & 0xf0) == 0) {

  0115d	a8 f0		 test	 al, 240			; 000000f0H
  0115f	0f 85 b7 00 00
	00		 jne	 $LN857@inflate

; 1086 :                 last = here;
; 1087 :                 for (;;) {
; 1088 :                     here = state->distcode[last.val +
; 1089 :                             (BITS(last.bits + last.op) >> last.bits)];

  01165	8b c8		 mov	 ecx, eax
  01167	bb 01 00 00 00	 mov	 ebx, 1
  0116c	c1 e9 08	 shr	 ecx, 8
  0116f	8b d0		 mov	 edx, eax
  01171	0f b6 f9	 movzx	 edi, cl
  01174	89 4d d8	 mov	 DWORD PTR tv2658[ebp], ecx
  01177	0f b6 c8	 movzx	 ecx, al
  0117a	03 cf		 add	 ecx, edi
  0117c	c1 e8 10	 shr	 eax, 16			; 00000010H
  0117f	d3 e3		 shl	 ebx, cl
  01181	8b cf		 mov	 ecx, edi
  01183	4b		 dec	 ebx
  01184	89 55 c8	 mov	 DWORD PTR _last$[ebp], edx
  01187	23 5d fc	 and	 ebx, DWORD PTR _hold$1$[ebp]
  0118a	d3 eb		 shr	 ebx, cl
  0118c	8b 4d cc	 mov	 ecx, DWORD PTR tv2636[ebp]
  0118f	03 d8		 add	 ebx, eax
  01191	8b 04 99	 mov	 eax, DWORD PTR [ecx+ebx*4]

; 1090 :                     if ((unsigned)(last.bits + here.bits) <= bits) break;

  01194	8b c8		 mov	 ecx, eax
  01196	c1 e9 08	 shr	 ecx, 8
  01199	0f b6 f9	 movzx	 edi, cl
  0119c	8b 4d d8	 mov	 ecx, DWORD PTR tv2658[ebp]
  0119f	0f b6 c9	 movzx	 ecx, cl
  011a2	03 f9		 add	 edi, ecx
  011a4	3b fe		 cmp	 edi, esi
  011a6	76 5f		 jbe	 SHORT $LN83@inflate
  011a8	eb 06 8d 9b 00
	00 00 00	 npad	 8
$LL90@inflate:

; 1091 :                     PULLBYTE();

  011b0	8b 45 f4	 mov	 eax, DWORD PTR _have$1$[ebp]
  011b3	85 c0		 test	 eax, eax
  011b5	0f 84 c2 f3 ff
	ff		 je	 $LN862@inflate
  011bb	8b 5d f0	 mov	 ebx, DWORD PTR _next$1$[ebp]
  011be	48		 dec	 eax
  011bf	89 45 f4	 mov	 DWORD PTR _have$1$[ebp], eax
  011c2	8b ce		 mov	 ecx, esi
  011c4	bf 01 00 00 00	 mov	 edi, 1
  011c9	83 c6 08	 add	 esi, 8
  011cc	0f b6 03	 movzx	 eax, BYTE PTR [ebx]
  011cf	43		 inc	 ebx
  011d0	d3 e0		 shl	 eax, cl
  011d2	01 45 fc	 add	 DWORD PTR _hold$1$[ebp], eax
  011d5	0f b7 45 ca	 movzx	 eax, WORD PTR _last$[ebp+2]
  011d9	89 5d f0	 mov	 DWORD PTR _next$1$[ebp], ebx
  011dc	0f b6 de	 movzx	 ebx, dh
  011df	0f b6 ca	 movzx	 ecx, dl
  011e2	03 cb		 add	 ecx, ebx
  011e4	d3 e7		 shl	 edi, cl
  011e6	8b cb		 mov	 ecx, ebx
  011e8	4f		 dec	 edi
  011e9	23 7d fc	 and	 edi, DWORD PTR _hold$1$[ebp]
  011ec	d3 ef		 shr	 edi, cl
  011ee	03 f8		 add	 edi, eax
  011f0	8b 45 f8	 mov	 eax, DWORD PTR _state$1$[ebp]
  011f3	8b 40 50	 mov	 eax, DWORD PTR [eax+80]
  011f6	8b 04 b8	 mov	 eax, DWORD PTR [eax+edi*4]
  011f9	8b c8		 mov	 ecx, eax
  011fb	c1 e9 08	 shr	 ecx, 8
  011fe	0f b6 c9	 movzx	 ecx, cl
  01201	03 cb		 add	 ecx, ebx
  01203	3b ce		 cmp	 ecx, esi
  01205	77 a9		 ja	 SHORT $LL90@inflate
$LN83@inflate:

; 1092 :                 }
; 1093 :                 DROPBITS(last.bits);
; 1094 :                 state->back += last.bits;

  01207	8b 5d f8	 mov	 ebx, DWORD PTR _state$1$[ebp]
  0120a	0f b6 ce	 movzx	 ecx, dh
  0120d	8b 55 fc	 mov	 edx, DWORD PTR _hold$1$[ebp]
  01210	2b f1		 sub	 esi, ecx
  01212	d3 ea		 shr	 edx, cl
  01214	01 8b c4 1b 00
	00		 add	 DWORD PTR [ebx+7108], ecx
  0121a	eb 03		 jmp	 SHORT $LN80@inflate
$LN857@inflate:
  0121c	8b 5d f8	 mov	 ebx, DWORD PTR _state$1$[ebp]
$LN80@inflate:

; 1101 :                 break;

  0121f	8b 7d f0	 mov	 edi, DWORD PTR _next$1$[ebp]
  01222	8b c8		 mov	 ecx, eax
  01224	c1 e9 08	 shr	 ecx, 8
  01227	0f b6 c9	 movzx	 ecx, cl
  0122a	01 8b c4 1b 00
	00		 add	 DWORD PTR [ebx+7108], ecx
  01230	2b f1		 sub	 esi, ecx
  01232	d3 ea		 shr	 edx, cl
  01234	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  01237	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi
  0123a	a8 40		 test	 al, 64			; 00000040H
  0123c	74 1b		 je	 SHORT $LN77@inflate

; 1095 :             }
; 1096 :             DROPBITS(here.bits);
; 1097 :             state->back += here.bits;
; 1098 :             if (here.op & 64) {
; 1099 :                 strm->msg = (char *)"invalid distance code";
; 1100 :                 state->mode = BAD;

  0123e	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  01241	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]

; 1101 :                 break;

  01244	8b 5d f4	 mov	 ebx, DWORD PTR _have$1$[ebp]
  01247	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BG@LBKINIKP@invalid?5distance?5code?$AA@
  0124e	c7 01 1d 00 00
	00		 mov	 DWORD PTR [ecx], 29	; 0000001dH
  01254	e9 b3 f8 ff ff	 jmp	 $LN490@inflate
$LN77@inflate:

; 1102 :             }
; 1103 :             state->offset = (unsigned)here.val;

  01259	8b c8		 mov	 ecx, eax

; 1104 :             state->extra = (unsigned)(here.op) & 15;

  0125b	0f b6 c0	 movzx	 eax, al
  0125e	c1 e9 10	 shr	 ecx, 16			; 00000010H
  01261	83 e0 0f	 and	 eax, 15			; 0000000fH
  01264	89 4b 44	 mov	 DWORD PTR [ebx+68], ecx
  01267	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  0126a	8b 5d f4	 mov	 ebx, DWORD PTR _have$1$[ebp]
  0126d	89 41 48	 mov	 DWORD PTR [ecx+72], eax

; 1105 :             state->mode = DISTEXT;

  01270	c7 01 17 00 00
	00		 mov	 DWORD PTR [ecx], 23	; 00000017H
$LN76@inflate:

; 1106 :         case DISTEXT:
; 1107 :             if (state->extra) {

  01276	8b 41 48	 mov	 eax, DWORD PTR [ecx+72]
  01279	89 45 c8	 mov	 DWORD PTR tv2638[ebp], eax
  0127c	85 c0		 test	 eax, eax
  0127e	74 53		 je	 SHORT $LN75@inflate

; 1108 :                 NEEDBITS(state->extra);

  01280	3b f0		 cmp	 esi, eax
  01282	73 24		 jae	 SHORT $LN73@inflate
$LL71@inflate:
  01284	85 db		 test	 ebx, ebx
  01286	0f 84 ee f2 ff
	ff		 je	 $LN852@inflate
  0128c	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  0128f	8b ce		 mov	 ecx, esi
  01291	d3 e0		 shl	 eax, cl
  01293	4b		 dec	 ebx
  01294	03 d0		 add	 edx, eax
  01296	89 5d f4	 mov	 DWORD PTR _have$1$[ebp], ebx
  01299	47		 inc	 edi
  0129a	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  0129d	83 c6 08	 add	 esi, 8
  012a0	89 7d f0	 mov	 DWORD PTR _next$1$[ebp], edi
  012a3	3b 75 c8	 cmp	 esi, DWORD PTR tv2638[ebp]
  012a6	72 dc		 jb	 SHORT $LL71@inflate
$LN73@inflate:

; 1109 :                 state->offset += BITS(state->extra);

  012a8	8b 4d c8	 mov	 ecx, DWORD PTR tv2638[ebp]
  012ab	b8 01 00 00 00	 mov	 eax, 1
  012b0	d3 e0		 shl	 eax, cl
  012b2	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  012b5	48		 dec	 eax
  012b6	23 c2		 and	 eax, edx
  012b8	01 41 44	 add	 DWORD PTR [ecx+68], eax

; 1110 :                 DROPBITS(state->extra);

  012bb	8b 45 c8	 mov	 eax, DWORD PTR tv2638[ebp]
  012be	8b c8		 mov	 ecx, eax
  012c0	d3 ea		 shr	 edx, cl
  012c2	2b f0		 sub	 esi, eax

; 1111 :                 state->back += state->extra;

  012c4	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  012c7	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  012ca	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi
  012cd	01 81 c4 1b 00
	00		 add	 DWORD PTR [ecx+7108], eax
$LN75@inflate:

; 1112 :             }
; 1113 : #ifdef INFLATE_STRICT
; 1114 :             if (state->offset > state->dmax) {
; 1115 :                 strm->msg = (char *)"invalid distance too far back";
; 1116 :                 state->mode = BAD;
; 1117 :                 break;
; 1118 :             }
; 1119 : #endif
; 1120 :             Tracevv((stderr, "inflate:         distance %u\n", state->offset));
; 1121 :             state->mode = MATCH;

  012d3	c7 01 18 00 00
	00		 mov	 DWORD PTR [ecx], 24	; 00000018H
$LN62@inflate:

; 1122 :         case MATCH:
; 1123 :             if (left == 0) goto inf_leave;

  012d9	83 7d e8 00	 cmp	 DWORD PTR _left$1$[ebp], 0
  012dd	0f 84 97 f2 ff
	ff		 je	 $LN852@inflate

; 1124 :             copy = out - left;

  012e3	8b 45 dc	 mov	 eax, DWORD PTR _out$1$[ebp]
  012e6	2b 45 e8	 sub	 eax, DWORD PTR _left$1$[ebp]
  012e9	89 45 c8	 mov	 DWORD PTR _copy$9$[ebp], eax

; 1125 :             if (state->offset > copy) {         /* copy from window */

  012ec	8b 41 44	 mov	 eax, DWORD PTR [ecx+68]
  012ef	3b 45 c8	 cmp	 eax, DWORD PTR _copy$9$[ebp]
  012f2	76 54		 jbe	 SHORT $LN60@inflate

; 1126 :                 copy = state->offset - copy;

  012f4	2b 45 c8	 sub	 eax, DWORD PTR _copy$9$[ebp]

; 1127 :                 if (copy > state->whave) {

  012f7	3b 41 2c	 cmp	 eax, DWORD PTR [ecx+44]
  012fa	76 1e		 jbe	 SHORT $LN58@inflate

; 1128 :                     if (state->sane) {

  012fc	83 b9 c0 1b 00
	00 00		 cmp	 DWORD PTR [ecx+7104], 0
  01303	74 15		 je	 SHORT $LN58@inflate

; 1129 :                         strm->msg = (char *)"invalid distance too far back";

  01305	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  01308	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BO@ECPMAOGG@invalid?5distance?5too?5far?5back?$AA@
  0130f	c7 01 1d 00 00
	00		 mov	 DWORD PTR [ecx], 29	; 0000001dH
  01315	e9 f2 f7 ff ff	 jmp	 $LN490@inflate
$LN58@inflate:

; 1130 :                         state->mode = BAD;
; 1131 :                         break;
; 1132 :                     }
; 1133 : #ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
; 1134 :                     Trace((stderr, "inflate.c too far\n"));
; 1135 :                     copy -= state->whave;
; 1136 :                     if (copy > state->length) copy = state->length;
; 1137 :                     if (copy > left) copy = left;
; 1138 :                     left -= copy;
; 1139 :                     state->length -= copy;
; 1140 :                     do {
; 1141 :                         *put++ = 0;
; 1142 :                     } while (--copy);
; 1143 :                     if (state->length == 0) state->mode = LEN;
; 1144 :                     break;
; 1145 : #endif
; 1146 :                 }
; 1147 :                 if (copy > state->wnext) {

  0131a	3b 41 30	 cmp	 eax, DWORD PTR [ecx+48]
  0131d	76 10		 jbe	 SHORT $LN57@inflate

; 1148 :                     copy -= state->wnext;
; 1149 :                     from = state->window + (state->wsize - copy);

  0131f	8b 79 34	 mov	 edi, DWORD PTR [ecx+52]
  01322	2b 41 30	 sub	 eax, DWORD PTR [ecx+48]
  01325	03 79 28	 add	 edi, DWORD PTR [ecx+40]
  01328	2b f8		 sub	 edi, eax
  0132a	89 7d d8	 mov	 DWORD PTR _from$1$[ebp], edi

; 1150 :                 }
; 1151 :                 else

  0132d	eb 0b		 jmp	 SHORT $LN56@inflate
$LN57@inflate:

; 1152 :                     from = state->window + (state->wnext - copy);

  0132f	8b 59 34	 mov	 ebx, DWORD PTR [ecx+52]
  01332	2b d8		 sub	 ebx, eax
  01334	03 59 30	 add	 ebx, DWORD PTR [ecx+48]
  01337	89 5d d8	 mov	 DWORD PTR _from$1$[ebp], ebx
$LN56@inflate:

; 1153 :                 if (copy > state->length) copy = state->length;

  0133a	8b 79 40	 mov	 edi, DWORD PTR [ecx+64]
  0133d	89 7d c8	 mov	 DWORD PTR tv2595[ebp], edi
  01340	3b c7		 cmp	 eax, edi
  01342	76 13		 jbe	 SHORT $LN54@inflate
  01344	8b c7		 mov	 eax, edi

; 1154 :             }
; 1155 :             else {                              /* copy from output */

  01346	eb 0f		 jmp	 SHORT $LN54@inflate
$LN60@inflate:

; 1156 :                 from = put - state->offset;

  01348	8b 5d e0	 mov	 ebx, DWORD PTR _put$1$[ebp]
  0134b	89 5d d8	 mov	 DWORD PTR _from$1$[ebp], ebx
  0134e	29 45 d8	 sub	 DWORD PTR _from$1$[ebp], eax

; 1157 :                 copy = state->length;

  01351	8b 41 40	 mov	 eax, DWORD PTR [ecx+64]
  01354	89 45 c8	 mov	 DWORD PTR tv2595[ebp], eax
$LN54@inflate:

; 1158 :             }
; 1159 :             if (copy > left) copy = left;

  01357	8b 5d e8	 mov	 ebx, DWORD PTR _left$1$[ebp]
  0135a	3b c3		 cmp	 eax, ebx
  0135c	0f 47 c3	 cmova	 eax, ebx

; 1160 :             left -= copy;

  0135f	2b d8		 sub	 ebx, eax
  01361	89 45 cc	 mov	 DWORD PTR _copy$11$[ebp], eax
  01364	89 5d e8	 mov	 DWORD PTR _left$1$[ebp], ebx
  01367	8b f8		 mov	 edi, eax

; 1161 :             state->length -= copy;

  01369	8b 5d c8	 mov	 ebx, DWORD PTR tv2595[ebp]
  0136c	2b d8		 sub	 ebx, eax
  0136e	89 59 40	 mov	 DWORD PTR [ecx+64], ebx

; 1164 :             } while (--copy);

  01371	8b 5d d8	 mov	 ebx, DWORD PTR _from$1$[ebp]
  01374	8b 4d e0	 mov	 ecx, DWORD PTR _put$1$[ebp]
  01377	2b d9		 sub	 ebx, ecx
  01379	8d a4 24 00 00
	00 00		 npad	 7
$LL52@inflate:

; 1162 :             do {
; 1163 :                 *put++ = *from++;

  01380	8a 04 0b	 mov	 al, BYTE PTR [ebx+ecx]
  01383	88 01		 mov	 BYTE PTR [ecx], al
  01385	41		 inc	 ecx

; 1164 :             } while (--copy);

  01386	4f		 dec	 edi
  01387	75 f7		 jne	 SHORT $LL52@inflate

; 1165 :             if (state->length == 0) state->mode = LEN;

  01389	8b 5d f4	 mov	 ebx, DWORD PTR _have$1$[ebp]
  0138c	8b 7d f0	 mov	 edi, DWORD PTR _next$1$[ebp]
  0138f	89 4d e0	 mov	 DWORD PTR _put$1$[ebp], ecx
  01392	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  01395	83 79 40 00	 cmp	 DWORD PTR [ecx+64], 0
  01399	0f 85 6d f7 ff
	ff		 jne	 $LN490@inflate
  0139f	c7 01 14 00 00
	00		 mov	 DWORD PTR [ecx], 20	; 00000014H

; 1166 :             break;

  013a5	e9 62 f7 ff ff	 jmp	 $LN490@inflate
$LN48@inflate:

; 1167 :         case LIT:
; 1168 :             if (left == 0) goto inf_leave;

  013aa	83 7d e8 00	 cmp	 DWORD PTR _left$1$[ebp], 0
  013ae	0f 84 c6 f1 ff
	ff		 je	 $LN852@inflate

; 1169 :             *put++ = (unsigned char)(state->length);

  013b4	8b 7d e0	 mov	 edi, DWORD PTR _put$1$[ebp]
  013b7	8a 41 40	 mov	 al, BYTE PTR [ecx+64]
  013ba	ff 45 e0	 inc	 DWORD PTR _put$1$[ebp]

; 1170 :             left--;

  013bd	ff 4d e8	 dec	 DWORD PTR _left$1$[ebp]
  013c0	88 07		 mov	 BYTE PTR [edi], al

; 1171 :             state->mode = LEN;
; 1172 :             break;

  013c2	8b 7d f0	 mov	 edi, DWORD PTR _next$1$[ebp]
  013c5	c7 01 14 00 00
	00		 mov	 DWORD PTR [ecx], 20	; 00000014H
  013cb	e9 3c f7 ff ff	 jmp	 $LN490@inflate
$LN46@inflate:

; 1173 :         case CHECK:
; 1174 :             if (state->wrap) {

  013d0	83 79 08 00	 cmp	 DWORD PTR [ecx+8], 0
  013d4	0f 84 d5 00 00
	00		 je	 $LN31@inflate

; 1175 :                 NEEDBITS(32);

  013da	83 fe 20	 cmp	 esi, 32			; 00000020H
  013dd	73 2b		 jae	 SHORT $LN43@inflate
  013df	90		 npad	 1
$LL41@inflate:
  013e0	85 db		 test	 ebx, ebx
  013e2	0f 84 92 f1 ff
	ff		 je	 $LN852@inflate
  013e8	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  013eb	8b ce		 mov	 ecx, esi
  013ed	d3 e0		 shl	 eax, cl
  013ef	83 c6 08	 add	 esi, 8
  013f2	4b		 dec	 ebx
  013f3	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi
  013f6	03 d0		 add	 edx, eax
  013f8	89 5d f4	 mov	 DWORD PTR _have$1$[ebp], ebx
  013fb	47		 inc	 edi
  013fc	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  013ff	89 7d f0	 mov	 DWORD PTR _next$1$[ebp], edi
  01402	83 fe 20	 cmp	 esi, 32			; 00000020H
  01405	72 d9		 jb	 SHORT $LL41@inflate
  01407	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
$LN43@inflate:

; 1176 :                 out -= left;

  0140a	8b 45 e8	 mov	 eax, DWORD PTR _left$1$[ebp]
  0140d	29 45 dc	 sub	 DWORD PTR _out$1$[ebp], eax

; 1177 :                 strm->total_out += out;

  01410	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  01413	8b 7d dc	 mov	 edi, DWORD PTR _out$1$[ebp]
  01416	01 78 14	 add	 DWORD PTR [eax+20], edi

; 1178 :                 state->total += out;

  01419	8b c7		 mov	 eax, edi
  0141b	01 41 1c	 add	 DWORD PTR [ecx+28], eax

; 1179 :                 if (out)

  0141e	8b 7d f0	 mov	 edi, DWORD PTR _next$1$[ebp]
  01421	85 c0		 test	 eax, eax
  01423	74 2c		 je	 SHORT $LN35@inflate

; 1180 :                     strm->adler = state->check =
; 1181 :                         UPDATE(state->check, put - out, out);

  01425	50		 push	 eax
  01426	8b 45 e0	 mov	 eax, DWORD PTR _put$1$[ebp]
  01429	2b 45 dc	 sub	 eax, DWORD PTR _out$1$[ebp]
  0142c	83 79 10 00	 cmp	 DWORD PTR [ecx+16], 0
  01430	50		 push	 eax
  01431	ff 71 18	 push	 DWORD PTR [ecx+24]
  01434	74 07		 je	 SHORT $LN504@inflate
  01436	e8 00 00 00 00	 call	 _crc32@12
  0143b	eb 05		 jmp	 SHORT $LN505@inflate
$LN504@inflate:
  0143d	e8 00 00 00 00	 call	 _adler32@12
$LN505@inflate:
  01442	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  01445	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  01448	89 41 18	 mov	 DWORD PTR [ecx+24], eax
  0144b	89 42 30	 mov	 DWORD PTR [edx+48], eax
  0144e	8b 55 fc	 mov	 edx, DWORD PTR _hold$1$[ebp]
$LN35@inflate:

; 1182 :                 out = left;
; 1183 :                 if ((
; 1184 : #ifdef GUNZIP
; 1185 :                      state->flags ? hold :
; 1186 : #endif
; 1187 :                      ZSWAP32(hold)) != state->check) {

  01451	83 79 10 00	 cmp	 DWORD PTR [ecx+16], 0
  01455	8b 45 e8	 mov	 eax, DWORD PTR _left$1$[ebp]
  01458	89 45 dc	 mov	 DWORD PTR _out$1$[ebp], eax
  0145b	8b c2		 mov	 eax, edx
  0145d	75 2c		 jne	 SHORT $LN507@inflate
  0145f	25 00 ff 00 00	 and	 eax, 65280		; 0000ff00H
  01464	89 45 d8	 mov	 DWORD PTR tv2758[ebp], eax
  01467	8b c2		 mov	 eax, edx
  01469	c1 e0 10	 shl	 eax, 16			; 00000010H
  0146c	01 45 d8	 add	 DWORD PTR tv2758[ebp], eax
  0146f	8b c2		 mov	 eax, edx
  01471	c1 65 d8 08	 shl	 DWORD PTR tv2758[ebp], 8
  01475	c1 e8 08	 shr	 eax, 8
  01478	25 00 ff 00 00	 and	 eax, 65280		; 0000ff00H
  0147d	01 45 d8	 add	 DWORD PTR tv2758[ebp], eax
  01480	8b c2		 mov	 eax, edx
  01482	c1 e8 18	 shr	 eax, 24			; 00000018H
  01485	01 45 d8	 add	 DWORD PTR tv2758[ebp], eax
  01488	8b 45 d8	 mov	 eax, DWORD PTR tv2758[ebp]
$LN507@inflate:
  0148b	3b 41 18	 cmp	 eax, DWORD PTR [ecx+24]
  0148e	74 15		 je	 SHORT $LN33@inflate

; 1188 :                     strm->msg = (char *)"incorrect data check";

  01490	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  01493	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BF@MEIGEHBE@incorrect?5data?5check?$AA@
  0149a	c7 01 1d 00 00
	00		 mov	 DWORD PTR [ecx], 29	; 0000001dH
  014a0	e9 67 f6 ff ff	 jmp	 $LN490@inflate
$LN33@inflate:

; 1189 :                     state->mode = BAD;
; 1190 :                     break;
; 1191 :                 }
; 1192 :                 INITBITS();

  014a5	33 d2		 xor	 edx, edx
  014a7	33 f6		 xor	 esi, esi
  014a9	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  014ac	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi
$LN31@inflate:

; 1193 :                 Tracev((stderr, "inflate:   check matches trailer\n"));
; 1194 :             }
; 1195 : #ifdef GUNZIP
; 1196 :             state->mode = LENGTH;

  014af	c7 01 1b 00 00
	00		 mov	 DWORD PTR [ecx], 27	; 0000001bH
$LN30@inflate:

; 1197 :         case LENGTH:
; 1198 :             if (state->wrap && state->flags) {

  014b5	83 79 08 00	 cmp	 DWORD PTR [ecx+8], 0
  014b9	0f 84 89 00 00
	00		 je	 $LN16@inflate
  014bf	83 79 10 00	 cmp	 DWORD PTR [ecx+16], 0
  014c3	0f 84 7f 00 00
	00		 je	 $LN16@inflate

; 1199 :                 NEEDBITS(32);

  014c9	83 fe 20	 cmp	 esi, 32			; 00000020H
  014cc	73 2c		 jae	 SHORT $LN27@inflate
  014ce	8b ff		 npad	 2
$LL25@inflate:
  014d0	85 db		 test	 ebx, ebx
  014d2	0f 84 a2 f0 ff
	ff		 je	 $LN852@inflate
  014d8	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  014db	8b ce		 mov	 ecx, esi
  014dd	d3 e0		 shl	 eax, cl
  014df	83 c6 08	 add	 esi, 8
  014e2	4b		 dec	 ebx
  014e3	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi
  014e6	03 d0		 add	 edx, eax
  014e8	89 5d f4	 mov	 DWORD PTR _have$1$[ebp], ebx
  014eb	47		 inc	 edi
  014ec	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  014ef	89 7d f0	 mov	 DWORD PTR _next$1$[ebp], edi
  014f2	83 fe 20	 cmp	 esi, 32			; 00000020H
  014f5	72 d9		 jb	 SHORT $LL25@inflate
  014f7	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
$LN27@inflate:

; 1200 :                 if (hold != (state->total & 0xffffffffUL)) {

  014fa	3b 51 1c	 cmp	 edx, DWORD PTR [ecx+28]
  014fd	74 40		 je	 SHORT $LN18@inflate

; 1201 :                     strm->msg = (char *)"incorrect length check";

  014ff	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  01502	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BH@FGKKJGOC@incorrect?5length?5check?$AA@
  01509	c7 01 1d 00 00
	00		 mov	 DWORD PTR [ecx], 29	; 0000001dH
  0150f	e9 f8 f5 ff ff	 jmp	 $LN490@inflate
$LN579@inflate:

; 820  :                 RESTORE();

  01514	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  01517	8b 4d e0	 mov	 ecx, DWORD PTR _put$1$[ebp]
  0151a	89 48 0c	 mov	 DWORD PTR [eax+12], ecx
  0151d	8b 4d e8	 mov	 ecx, DWORD PTR _left$1$[ebp]
  01520	89 48 10	 mov	 DWORD PTR [eax+16], ecx
  01523	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  01526	89 38		 mov	 DWORD PTR [eax], edi
  01528	89 58 04	 mov	 DWORD PTR [eax+4], ebx

; 821  :                 return Z_NEED_DICT;

  0152b	b8 02 00 00 00	 mov	 eax, 2
  01530	5f		 pop	 edi
  01531	89 71 3c	 mov	 DWORD PTR [ecx+60], esi
  01534	5e		 pop	 esi
  01535	89 51 38	 mov	 DWORD PTR [ecx+56], edx
  01538	5b		 pop	 ebx

; 1249 :         ret = Z_BUF_ERROR;
; 1250 :     return ret;
; 1251 : }

  01539	8b e5		 mov	 esp, ebp
  0153b	5d		 pop	 ebp
  0153c	c2 08 00	 ret	 8
$LN18@inflate:

; 1202 :                     state->mode = BAD;
; 1203 :                     break;
; 1204 :                 }
; 1205 :                 INITBITS();

  0153f	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _hold$1$[ebp], 0
  01546	33 f6		 xor	 esi, esi
$LN16@inflate:

; 1206 :                 Tracev((stderr, "inflate:   length matches trailer\n"));
; 1207 :             }
; 1208 : #endif
; 1209 :             state->mode = DONE;

  01548	c7 01 1c 00 00
	00		 mov	 DWORD PTR [ecx], 28	; 0000001cH
$LN15@inflate:

; 1210 :         case DONE:
; 1211 :             ret = Z_STREAM_END;

  0154e	c7 45 d4 01 00
	00 00		 mov	 DWORD PTR _ret$1$[ebp], 1

; 1212 :             goto inf_leave;

  01555	e9 20 f0 ff ff	 jmp	 $LN852@inflate
$LN14@inflate:

; 1213 :         case BAD:
; 1214 :             ret = Z_DATA_ERROR;

  0155a	c7 45 d4 fd ff
	ff ff		 mov	 DWORD PTR _ret$1$[ebp], -3 ; fffffffdH
  01561	e9 14 f0 ff ff	 jmp	 $LN852@inflate
$LN828@inflate:
  01566	8b 45 f4	 mov	 eax, DWORD PTR _have$1$[ebp]
  01569	e9 12 f0 ff ff	 jmp	 $inf_leave$903
$LN5@inflate:

; 1236 :         }
; 1237 :     in -= strm->avail_in;

  0156e	8b 45 c4	 mov	 eax, DWORD PTR _in$1$[ebp]
  01571	2b 47 04	 sub	 eax, DWORD PTR [edi+4]

; 1238 :     out -= strm->avail_out;

  01574	2b 77 10	 sub	 esi, DWORD PTR [edi+16]

; 1239 :     strm->total_in += in;

  01577	01 47 08	 add	 DWORD PTR [edi+8], eax

; 1240 :     strm->total_out += out;

  0157a	01 77 14	 add	 DWORD PTR [edi+20], esi

; 1241 :     state->total += out;

  0157d	01 73 1c	 add	 DWORD PTR [ebx+28], esi

; 1242 :     if (state->wrap && out)

  01580	83 7b 08 00	 cmp	 DWORD PTR [ebx+8], 0
  01584	89 45 c4	 mov	 DWORD PTR _in$1$[ebp], eax
  01587	89 75 dc	 mov	 DWORD PTR _out$1$[ebp], esi
  0158a	74 26		 je	 SHORT $LN4@inflate
  0158c	85 f6		 test	 esi, esi
  0158e	74 22		 je	 SHORT $LN4@inflate

; 1243 :         strm->adler = state->check =
; 1244 :             UPDATE(state->check, strm->next_out - out, out);

  01590	8b 47 0c	 mov	 eax, DWORD PTR [edi+12]
  01593	56		 push	 esi
  01594	2b c6		 sub	 eax, esi
  01596	83 7b 10 00	 cmp	 DWORD PTR [ebx+16], 0
  0159a	50		 push	 eax
  0159b	ff 73 18	 push	 DWORD PTR [ebx+24]
  0159e	74 07		 je	 SHORT $LN508@inflate
  015a0	e8 00 00 00 00	 call	 _crc32@12
  015a5	eb 05		 jmp	 SHORT $LN509@inflate
$LN508@inflate:
  015a7	e8 00 00 00 00	 call	 _adler32@12
$LN509@inflate:
  015ac	89 43 18	 mov	 DWORD PTR [ebx+24], eax
  015af	89 47 30	 mov	 DWORD PTR [edi+48], eax
$LN4@inflate:

; 1245 :     strm->data_type = state->bits + (state->last ? 64 : 0) +
; 1246 :                       (state->mode == TYPE ? 128 : 0) +
; 1247 :                       (state->mode == LEN_ || state->mode == COPY_ ? 256 : 0);

  015b2	8b 13		 mov	 edx, DWORD PTR [ebx]
  015b4	83 fa 13	 cmp	 edx, 19			; 00000013H
  015b7	74 09		 je	 SHORT $LN510@inflate
  015b9	83 fa 0e	 cmp	 edx, 14			; 0000000eH
  015bc	74 04		 je	 SHORT $LN510@inflate
  015be	33 f6		 xor	 esi, esi
  015c0	eb 05		 jmp	 SHORT $LN511@inflate
$LN510@inflate:
  015c2	be 00 01 00 00	 mov	 esi, 256		; 00000100H
$LN511@inflate:
  015c7	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  015ca	f7 d9		 neg	 ecx
  015cc	c7 45 08 80 00
	00 00		 mov	 DWORD PTR tv2620[ebp], 128 ; 00000080H
  015d3	1b c9		 sbb	 ecx, ecx
  015d5	33 c0		 xor	 eax, eax
  015d7	83 e1 40	 and	 ecx, 64			; 00000040H
  015da	83 fa 0b	 cmp	 edx, 11			; 0000000bH
  015dd	0f 44 45 08	 cmove	 eax, DWORD PTR tv2620[ebp]
  015e1	03 ce		 add	 ecx, esi
  015e3	03 c1		 add	 eax, ecx
  015e5	03 43 3c	 add	 eax, DWORD PTR [ebx+60]
  015e8	89 47 2c	 mov	 DWORD PTR [edi+44], eax

; 1248 :     if (((in == 0 && out == 0) || flush == Z_FINISH) && ret == Z_OK)

  015eb	8b 45 c4	 mov	 eax, DWORD PTR _in$1$[ebp]
  015ee	85 c0		 test	 eax, eax
  015f0	75 05		 jne	 SHORT $LN1@inflate
  015f2	39 45 dc	 cmp	 DWORD PTR _out$1$[ebp], eax
  015f5	74 06		 je	 SHORT $LN2@inflate
$LN1@inflate:
  015f7	83 7d 0c 04	 cmp	 DWORD PTR _flush$[ebp], 4
  015fb	75 16		 jne	 SHORT $LN860@inflate
$LN2@inflate:
  015fd	8b 45 d4	 mov	 eax, DWORD PTR _ret$1$[ebp]
  01600	b9 fb ff ff ff	 mov	 ecx, -5			; fffffffbH
  01605	5f		 pop	 edi
  01606	85 c0		 test	 eax, eax
  01608	5e		 pop	 esi
  01609	0f 44 c1	 cmove	 eax, ecx
  0160c	5b		 pop	 ebx

; 1249 :         ret = Z_BUF_ERROR;
; 1250 :     return ret;
; 1251 : }

  0160d	8b e5		 mov	 esp, ebp
  0160f	5d		 pop	 ebp
  01610	c2 08 00	 ret	 8
$LN860@inflate:
  01613	8b 45 d4	 mov	 eax, DWORD PTR _ret$1$[ebp]
  01616	5f		 pop	 edi
  01617	5e		 pop	 esi
  01618	5b		 pop	 ebx
  01619	8b e5		 mov	 esp, ebp
  0161b	5d		 pop	 ebp
  0161c	c2 08 00	 ret	 8
$LN498@inflate:

; 629  :         return Z_STREAM_ERROR;

  0161f	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH

; 1249 :         ret = Z_BUF_ERROR;
; 1250 :     return ret;
; 1251 : }

  01624	8b e5		 mov	 esp, ebp
  01626	5d		 pop	 ebp
  01627	c2 08 00	 ret	 8
  0162a	8b ff		 npad	 2
$LN901@inflate:
  0162c	00 00 00 00	 DD	 $LN489@inflate
  01630	00 00 00 00	 DD	 $LN457@inflate
  01634	00 00 00 00	 DD	 $LN437@inflate
  01638	00 00 00 00	 DD	 $LN419@inflate
  0163c	00 00 00 00	 DD	 $LN402@inflate
  01640	00 00 00 00	 DD	 $LN381@inflate
  01644	00 00 00 00	 DD	 $LN374@inflate
  01648	00 00 00 00	 DD	 $LN362@inflate
  0164c	00 00 00 00	 DD	 $LN350@inflate
  01650	00 00 00 00	 DD	 $LN333@inflate
  01654	00 00 00 00	 DD	 $LN321@inflate
  01658	00 00 00 00	 DD	 $LN316@inflate
  0165c	00 00 00 00	 DD	 $LN315@inflate
  01660	00 00 00 00	 DD	 $LN282@inflate
  01664	00 00 00 00	 DD	 $LN266@inflate
  01668	00 00 00 00	 DD	 $LN264@inflate
  0166c	00 00 00 00	 DD	 $LN258@inflate
  01670	00 00 00 00	 DD	 $LN525@inflate
  01674	00 00 00 00	 DD	 $LN528@inflate
  01678	00 00 00 00	 DD	 $LN148@inflate
  0167c	00 00 00 00	 DD	 $LN146@inflate
  01680	00 00 00 00	 DD	 $LN113@inflate
  01684	00 00 00 00	 DD	 $LN537@inflate
  01688	00 00 00 00	 DD	 $LN76@inflate
  0168c	00 00 00 00	 DD	 $LN62@inflate
  01690	00 00 00 00	 DD	 $LN48@inflate
  01694	00 00 00 00	 DD	 $LN46@inflate
  01698	00 00 00 00	 DD	 $LN30@inflate
  0169c	00 00 00 00	 DD	 $LN15@inflate
  016a0	00 00 00 00	 DD	 $LN14@inflate
  016a4	00 00 00 00	 DD	 $LN13@inflate
$LN902@inflate:
  016a8	00 00 00 00	 DD	 $LN294@inflate
  016ac	00 00 00 00	 DD	 $LN293@inflate
  016b0	00 00 00 00	 DD	 $LN288@inflate
  016b4	00 00 00 00	 DD	 $LN287@inflate
_inflate@8 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\workspace\cocos2d-x-3.8.1\projects\mygame\libs\smartfox\zlib\inflate.c
;	COMDAT _inflateReset@4
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_inflateReset@4 PROC					; COMDAT

; 130  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 131  :     struct inflate_state FAR *state;
; 132  : 
; 133  :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  00003	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	74 25		 je	 SHORT $LN1@inflateRes
  0000a	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  0000d	85 c9		 test	 ecx, ecx
  0000f	74 1e		 je	 SHORT $LN1@inflateRes

; 134  :     state = (struct inflate_state FAR *)strm->state;
; 135  :     state->wsize = 0;

  00011	c7 41 28 00 00
	00 00		 mov	 DWORD PTR [ecx+40], 0

; 136  :     state->whave = 0;

  00018	c7 41 2c 00 00
	00 00		 mov	 DWORD PTR [ecx+44], 0

; 137  :     state->wnext = 0;

  0001f	c7 41 30 00 00
	00 00		 mov	 DWORD PTR [ecx+48], 0

; 138  :     return inflateResetKeep(strm);

  00026	89 45 08	 mov	 DWORD PTR _strm$[ebp], eax

; 139  : }

  00029	5d		 pop	 ebp

; 138  :     return inflateResetKeep(strm);

  0002a	e9 00 00 00 00	 jmp	 _inflateResetKeep@4
$LN1@inflateRes:

; 131  :     struct inflate_state FAR *state;
; 132  : 
; 133  :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  0002f	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH

; 139  : }

  00034	5d		 pop	 ebp
  00035	c2 04 00	 ret	 4
_inflateReset@4 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\workspace\cocos2d-x-3.8.1\projects\mygame\libs\smartfox\zlib\inflate.c
;	COMDAT _inflateInit2_@16
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_windowBits$ = 12					; size = 4
_version$ = 16						; size = 4
_stream_size$ = 20					; size = 4
_inflateInit2_@16 PROC					; COMDAT

; 184  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 185  :     int ret;
; 186  :     struct inflate_state FAR *state;
; 187  : 
; 188  :     if (version == Z_NULL || version[0] != ZLIB_VERSION[0] ||
; 189  :         stream_size != (int)(sizeof(z_stream)))

  00003	8b 45 10	 mov	 eax, DWORD PTR _version$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	0f 84 a3 00 00
	00		 je	 $LN6@inflateIni
  0000e	80 38 31	 cmp	 BYTE PTR [eax], 49	; 00000031H
  00011	0f 85 9a 00 00
	00		 jne	 $LN6@inflateIni
  00017	83 7d 14 38	 cmp	 DWORD PTR _stream_size$[ebp], 56 ; 00000038H
  0001b	0f 85 90 00 00
	00		 jne	 $LN6@inflateIni

; 191  :     if (strm == Z_NULL) return Z_STREAM_ERROR;

  00021	56		 push	 esi
  00022	8b 75 08	 mov	 esi, DWORD PTR _strm$[ebp]
  00025	85 f6		 test	 esi, esi
  00027	75 08		 jne	 SHORT $LN5@inflateIni
  00029	8d 46 fe	 lea	 eax, DWORD PTR [esi-2]
  0002c	5e		 pop	 esi

; 219  : }

  0002d	5d		 pop	 ebp
  0002e	c2 10 00	 ret	 16			; 00000010H
$LN5@inflateIni:

; 192  :     strm->msg = Z_NULL;                 /* in case we return an error */
; 193  :     if (strm->zalloc == (alloc_func)0) {

  00031	83 7e 20 00	 cmp	 DWORD PTR [esi+32], 0
  00035	c7 46 18 00 00
	00 00		 mov	 DWORD PTR [esi+24], 0
  0003c	75 0e		 jne	 SHORT $LN4@inflateIni

; 194  : #ifdef Z_SOLO
; 195  :         return Z_STREAM_ERROR;
; 196  : #else
; 197  :         strm->zalloc = zcalloc;

  0003e	c7 46 20 00 00
	00 00		 mov	 DWORD PTR [esi+32], OFFSET _zcalloc

; 198  :         strm->opaque = (voidpf)0;

  00045	c7 46 28 00 00
	00 00		 mov	 DWORD PTR [esi+40], 0
$LN4@inflateIni:

; 199  : #endif
; 200  :     }
; 201  :     if (strm->zfree == (free_func)0)

  0004c	83 7e 24 00	 cmp	 DWORD PTR [esi+36], 0
  00050	75 07		 jne	 SHORT $LN3@inflateIni

; 202  : #ifdef Z_SOLO
; 203  :         return Z_STREAM_ERROR;
; 204  : #else
; 205  :         strm->zfree = zcfree;

  00052	c7 46 24 00 00
	00 00		 mov	 DWORD PTR [esi+36], OFFSET _zcfree
$LN3@inflateIni:

; 206  : #endif
; 207  :     state = (struct inflate_state FAR *)
; 208  :             ZALLOC(strm, 1, sizeof(struct inflate_state));

  00059	8b 46 20	 mov	 eax, DWORD PTR [esi+32]
  0005c	57		 push	 edi
  0005d	68 cc 1b 00 00	 push	 7116			; 00001bccH
  00062	6a 01		 push	 1
  00064	ff 76 28	 push	 DWORD PTR [esi+40]
  00067	ff d0		 call	 eax
  00069	8b f8		 mov	 edi, eax
  0006b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 209  :     if (state == Z_NULL) return Z_MEM_ERROR;

  0006e	85 ff		 test	 edi, edi
  00070	75 09		 jne	 SHORT $LN2@inflateIni
  00072	8d 47 fc	 lea	 eax, DWORD PTR [edi-4]
  00075	5f		 pop	 edi
  00076	5e		 pop	 esi

; 219  : }

  00077	5d		 pop	 ebp
  00078	c2 10 00	 ret	 16			; 00000010H
$LN2@inflateIni:
  0007b	53		 push	 ebx

; 210  :     Tracev((stderr, "inflate: allocated\n"));
; 211  :     strm->state = (struct internal_state FAR *)state;
; 212  :     state->window = Z_NULL;
; 213  :     ret = inflateReset2(strm, windowBits);

  0007c	ff 75 0c	 push	 DWORD PTR _windowBits$[ebp]
  0007f	89 7e 1c	 mov	 DWORD PTR [esi+28], edi
  00082	56		 push	 esi
  00083	c7 47 34 00 00
	00 00		 mov	 DWORD PTR [edi+52], 0
  0008a	e8 00 00 00 00	 call	 _inflateReset2@8
  0008f	8b d8		 mov	 ebx, eax

; 214  :     if (ret != Z_OK) {

  00091	85 db		 test	 ebx, ebx
  00093	74 13		 je	 SHORT $LN1@inflateIni

; 215  :         ZFREE(strm, state);

  00095	8b 4e 24	 mov	 ecx, DWORD PTR [esi+36]
  00098	57		 push	 edi
  00099	ff 76 28	 push	 DWORD PTR [esi+40]
  0009c	ff d1		 call	 ecx
  0009e	83 c4 08	 add	 esp, 8

; 216  :         strm->state = Z_NULL;

  000a1	c7 46 1c 00 00
	00 00		 mov	 DWORD PTR [esi+28], 0
$LN1@inflateIni:

; 217  :     }
; 218  :     return ret;

  000a8	8b c3		 mov	 eax, ebx
  000aa	5b		 pop	 ebx
  000ab	5f		 pop	 edi
  000ac	5e		 pop	 esi

; 219  : }

  000ad	5d		 pop	 ebp
  000ae	c2 10 00	 ret	 16			; 00000010H
$LN6@inflateIni:

; 190  :         return Z_VERSION_ERROR;

  000b1	b8 fa ff ff ff	 mov	 eax, -6			; fffffffaH

; 219  : }

  000b6	5d		 pop	 ebp
  000b7	c2 10 00	 ret	 16			; 00000010H
_inflateInit2_@16 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\workspace\cocos2d-x-3.8.1\projects\mygame\libs\smartfox\zlib\inflate.c
;	COMDAT _inflateResetKeep@4
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_inflateResetKeep@4 PROC				; COMDAT

; 105  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 106  :     struct inflate_state FAR *state;
; 107  : 
; 108  :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  00003	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	0f 84 8d 00 00
	00		 je	 $LN2@inflateRes
  0000e	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  00011	85 c9		 test	 ecx, ecx
  00013	0f 84 82 00 00
	00		 je	 $LN2@inflateRes

; 109  :     state = (struct inflate_state FAR *)strm->state;
; 110  :     strm->total_in = strm->total_out = state->total = 0;

  00019	c7 41 1c 00 00
	00 00		 mov	 DWORD PTR [ecx+28], 0
  00020	c7 40 14 00 00
	00 00		 mov	 DWORD PTR [eax+20], 0
  00027	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0

; 111  :     strm->msg = Z_NULL;

  0002e	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], 0

; 112  :     if (state->wrap)        /* to support ill-conceived Java test suite */

  00035	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00038	85 d2		 test	 edx, edx
  0003a	74 06		 je	 SHORT $LN1@inflateRes

; 113  :         strm->adler = state->wrap & 1;

  0003c	83 e2 01	 and	 edx, 1
  0003f	89 50 30	 mov	 DWORD PTR [eax+48], edx
$LN1@inflateRes:

; 114  :     state->mode = HEAD;
; 115  :     state->last = 0;
; 116  :     state->havedict = 0;
; 117  :     state->dmax = 32768U;
; 118  :     state->head = Z_NULL;
; 119  :     state->hold = 0;
; 120  :     state->bits = 0;
; 121  :     state->lencode = state->distcode = state->next = state->codes;

  00042	8d 81 30 05 00
	00		 lea	 eax, DWORD PTR [ecx+1328]
  00048	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
  0004e	89 41 6c	 mov	 DWORD PTR [ecx+108], eax
  00051	89 41 50	 mov	 DWORD PTR [ecx+80], eax
  00054	89 41 4c	 mov	 DWORD PTR [ecx+76], eax

; 122  :     state->sane = 1;
; 123  :     state->back = -1;
; 124  :     Tracev((stderr, "inflate: reset\n"));
; 125  :     return Z_OK;

  00057	33 c0		 xor	 eax, eax
  00059	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  00060	c7 41 0c 00 00
	00 00		 mov	 DWORD PTR [ecx+12], 0
  00067	c7 41 14 00 80
	00 00		 mov	 DWORD PTR [ecx+20], 32768 ; 00008000H
  0006e	c7 41 20 00 00
	00 00		 mov	 DWORD PTR [ecx+32], 0
  00075	c7 41 38 00 00
	00 00		 mov	 DWORD PTR [ecx+56], 0
  0007c	c7 41 3c 00 00
	00 00		 mov	 DWORD PTR [ecx+60], 0
  00083	c7 81 c0 1b 00
	00 01 00 00 00	 mov	 DWORD PTR [ecx+7104], 1
  0008d	c7 81 c4 1b 00
	00 ff ff ff ff	 mov	 DWORD PTR [ecx+7108], -1

; 126  : }

  00097	5d		 pop	 ebp
  00098	c2 04 00	 ret	 4
$LN2@inflateRes:

; 106  :     struct inflate_state FAR *state;
; 107  : 
; 108  :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  0009b	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH

; 126  : }

  000a0	5d		 pop	 ebp
  000a1	c2 04 00	 ret	 4
_inflateResetKeep@4 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\workspace\cocos2d-x-3.8.1\projects\mygame\libs\smartfox\zlib\inflate.c
;	COMDAT _inflateReset2@8
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_windowBits$ = 12					; size = 4
_inflateReset2@8 PROC					; COMDAT

; 144  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 145  :     int wrap;
; 146  :     struct inflate_state FAR *state;
; 147  : 
; 148  :     /* get the state */
; 149  :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  00003	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00006	57		 push	 edi
  00007	85 c0		 test	 eax, eax
  00009	74 73		 je	 SHORT $LN7@inflateRes
  0000b	8b 78 1c	 mov	 edi, DWORD PTR [eax+28]
  0000e	85 ff		 test	 edi, edi
  00010	74 6c		 je	 SHORT $LN7@inflateRes

; 150  :     state = (struct inflate_state FAR *)strm->state;
; 151  : 
; 152  :     /* extract wrap request from windowBits parameter */
; 153  :     if (windowBits < 0) {

  00012	53		 push	 ebx
  00013	56		 push	 esi
  00014	8b 75 0c	 mov	 esi, DWORD PTR _windowBits$[ebp]
  00017	85 f6		 test	 esi, esi
  00019	79 06		 jns	 SHORT $LN6@inflateRes

; 154  :         wrap = 0;

  0001b	33 db		 xor	 ebx, ebx

; 155  :         windowBits = -windowBits;

  0001d	f7 de		 neg	 esi

; 156  :     }
; 157  :     else {

  0001f	eb 0e		 jmp	 SHORT $LN4@inflateRes
$LN6@inflateRes:

; 158  :         wrap = (windowBits >> 4) + 1;

  00021	8b de		 mov	 ebx, esi
  00023	c1 fb 04	 sar	 ebx, 4
  00026	43		 inc	 ebx

; 159  : #ifdef GUNZIP
; 160  :         if (windowBits < 48)

  00027	83 fe 30	 cmp	 esi, 48			; 00000030H
  0002a	7d 03		 jge	 SHORT $LN4@inflateRes

; 161  :             windowBits &= 15;

  0002c	83 e6 0f	 and	 esi, 15			; 0000000fH
$LN4@inflateRes:

; 162  : #endif
; 163  :     }
; 164  : 
; 165  :     /* set number of window bits, free window if different */
; 166  :     if (windowBits && (windowBits < 8 || windowBits > 15))

  0002f	85 f6		 test	 esi, esi
  00031	74 16		 je	 SHORT $LN3@inflateRes
  00033	83 fe 08	 cmp	 esi, 8
  00036	7c 05		 jl	 SHORT $LN2@inflateRes
  00038	83 fe 0f	 cmp	 esi, 15			; 0000000fH
  0003b	7e 0c		 jle	 SHORT $LN3@inflateRes
$LN2@inflateRes:
  0003d	5e		 pop	 esi
  0003e	5b		 pop	 ebx

; 167  :         return Z_STREAM_ERROR;

  0003f	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  00044	5f		 pop	 edi

; 177  : }

  00045	5d		 pop	 ebp
  00046	c2 08 00	 ret	 8
$LN3@inflateRes:

; 168  :     if (state->window != Z_NULL && state->wbits != (unsigned)windowBits) {

  00049	8b 4f 34	 mov	 ecx, DWORD PTR [edi+52]
  0004c	85 c9		 test	 ecx, ecx
  0004e	74 1b		 je	 SHORT $LN1@inflateRes
  00050	39 77 24	 cmp	 DWORD PTR [edi+36], esi
  00053	74 16		 je	 SHORT $LN1@inflateRes

; 169  :         ZFREE(strm, state->window);

  00055	51		 push	 ecx
  00056	ff 70 28	 push	 DWORD PTR [eax+40]
  00059	8b 40 24	 mov	 eax, DWORD PTR [eax+36]
  0005c	ff d0		 call	 eax
  0005e	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00061	83 c4 08	 add	 esp, 8

; 170  :         state->window = Z_NULL;

  00064	c7 47 34 00 00
	00 00		 mov	 DWORD PTR [edi+52], 0
$LN1@inflateRes:

; 171  :     }
; 172  : 
; 173  :     /* update state and reset the rest of it */
; 174  :     state->wrap = wrap;
; 175  :     state->wbits = (unsigned)windowBits;
; 176  :     return inflateReset(strm);

  0006b	50		 push	 eax
  0006c	89 5f 08	 mov	 DWORD PTR [edi+8], ebx
  0006f	89 77 24	 mov	 DWORD PTR [edi+36], esi
  00072	e8 00 00 00 00	 call	 _inflateReset@4
  00077	5e		 pop	 esi
  00078	5b		 pop	 ebx
  00079	5f		 pop	 edi

; 177  : }

  0007a	5d		 pop	 ebp
  0007b	c2 08 00	 ret	 8
$LN7@inflateRes:

; 145  :     int wrap;
; 146  :     struct inflate_state FAR *state;
; 147  : 
; 148  :     /* get the state */
; 149  :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  0007e	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  00083	5f		 pop	 edi

; 177  : }

  00084	5d		 pop	 ebp
  00085	c2 08 00	 ret	 8
_inflateReset2@8 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\workspace\cocos2d-x-3.8.1\projects\mygame\libs\smartfox\zlib\inflate.c
;	COMDAT _inflateInit_@12
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_version$ = 12						; size = 4
_stream_size$ = 16					; size = 4
_inflateInit_@12 PROC					; COMDAT

; 225  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 226  :     return inflateInit2_(strm, DEF_WBITS, version, stream_size);

  00003	ff 75 10	 push	 DWORD PTR _stream_size$[ebp]
  00006	ff 75 0c	 push	 DWORD PTR _version$[ebp]
  00009	6a 0f		 push	 15			; 0000000fH
  0000b	ff 75 08	 push	 DWORD PTR _strm$[ebp]
  0000e	e8 00 00 00 00	 call	 _inflateInit2_@16

; 227  : }

  00013	5d		 pop	 ebp
  00014	c2 0c 00	 ret	 12			; 0000000cH
_inflateInit_@12 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\workspace\cocos2d-x-3.8.1\projects\mygame\libs\smartfox\zlib\inflate.c
;	COMDAT _inflatePrime@12
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_bits$ = 12						; size = 4
_value$ = 16						; size = 4
_inflatePrime@12 PROC					; COMDAT

; 233  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 234  :     struct inflate_state FAR *state;
; 235  : 
; 236  :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  00003	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  00006	85 d2		 test	 edx, edx
  00008	74 5c		 je	 SHORT $LN4@inflatePri
  0000a	8b 52 1c	 mov	 edx, DWORD PTR [edx+28]
  0000d	85 d2		 test	 edx, edx
  0000f	74 55		 je	 SHORT $LN4@inflatePri

; 237  :     state = (struct inflate_state FAR *)strm->state;
; 238  :     if (bits < 0) {

  00011	8b 4d 0c	 mov	 ecx, DWORD PTR _bits$[ebp]
  00014	85 c9		 test	 ecx, ecx
  00016	79 14		 jns	 SHORT $LN3@inflatePri

; 239  :         state->hold = 0;

  00018	c7 42 38 00 00
	00 00		 mov	 DWORD PTR [edx+56], 0

; 240  :         state->bits = 0;
; 241  :         return Z_OK;

  0001f	33 c0		 xor	 eax, eax
  00021	c7 42 3c 00 00
	00 00		 mov	 DWORD PTR [edx+60], 0

; 248  : }

  00028	5d		 pop	 ebp
  00029	c2 0c 00	 ret	 12			; 0000000cH
$LN3@inflatePri:
  0002c	56		 push	 esi
  0002d	57		 push	 edi

; 242  :     }
; 243  :     if (bits > 16 || state->bits + bits > 32) return Z_STREAM_ERROR;

  0002e	83 f9 10	 cmp	 ecx, 16			; 00000010H
  00031	7f 28		 jg	 SHORT $LN1@inflatePri
  00033	8b 72 3c	 mov	 esi, DWORD PTR [edx+60]
  00036	8d 3c 0e	 lea	 edi, DWORD PTR [esi+ecx]
  00039	83 ff 20	 cmp	 edi, 32			; 00000020H
  0003c	77 1d		 ja	 SHORT $LN1@inflatePri

; 244  :     value &= (1L << bits) - 1;

  0003e	b8 01 00 00 00	 mov	 eax, 1

; 245  :     state->hold += value << state->bits;
; 246  :     state->bits += bits;

  00043	89 7a 3c	 mov	 DWORD PTR [edx+60], edi
  00046	d3 e0		 shl	 eax, cl
  00048	8b ce		 mov	 ecx, esi
  0004a	48		 dec	 eax
  0004b	23 45 10	 and	 eax, DWORD PTR _value$[ebp]
  0004e	d3 e0		 shl	 eax, cl
  00050	01 42 38	 add	 DWORD PTR [edx+56], eax

; 247  :     return Z_OK;

  00053	33 c0		 xor	 eax, eax
  00055	5f		 pop	 edi
  00056	5e		 pop	 esi

; 248  : }

  00057	5d		 pop	 ebp
  00058	c2 0c 00	 ret	 12			; 0000000cH
$LN1@inflatePri:
  0005b	5f		 pop	 edi

; 242  :     }
; 243  :     if (bits > 16 || state->bits + bits > 32) return Z_STREAM_ERROR;

  0005c	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  00061	5e		 pop	 esi

; 248  : }

  00062	5d		 pop	 ebp
  00063	c2 0c 00	 ret	 12			; 0000000cH
$LN4@inflatePri:

; 234  :     struct inflate_state FAR *state;
; 235  : 
; 236  :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  00066	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH

; 248  : }

  0006b	5d		 pop	 ebp
  0006c	c2 0c 00	 ret	 12			; 0000000cH
_inflatePrime@12 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\workspace\cocos2d-x-3.8.1\projects\mygame\libs\smartfox\zlib\inflate.c
;	COMDAT _fixedtables
_TEXT	SEGMENT
_fixedtables PROC					; COMDAT
; _state$ = ecx

; 263  : #ifdef BUILDFIXED
; 264  :     static int virgin = 1;
; 265  :     static code *lenfix, *distfix;
; 266  :     static code fixed[544];
; 267  : 
; 268  :     /* build fixed huffman tables if first call (may not be thread safe) */
; 269  :     if (virgin) {
; 270  :         unsigned sym, bits;
; 271  :         static code *next;
; 272  : 
; 273  :         /* literal/length table */
; 274  :         sym = 0;
; 275  :         while (sym < 144) state->lens[sym++] = 8;
; 276  :         while (sym < 256) state->lens[sym++] = 9;
; 277  :         while (sym < 280) state->lens[sym++] = 7;
; 278  :         while (sym < 288) state->lens[sym++] = 8;
; 279  :         next = fixed;
; 280  :         lenfix = next;
; 281  :         bits = 9;
; 282  :         inflate_table(LENS, state->lens, 288, &(next), &(bits), state->work);
; 283  : 
; 284  :         /* distance table */
; 285  :         sym = 0;
; 286  :         while (sym < 32) state->lens[sym++] = 5;
; 287  :         distfix = next;
; 288  :         bits = 5;
; 289  :         inflate_table(DISTS, state->lens, 32, &(next), &(bits), state->work);
; 290  : 
; 291  :         /* do this just once */
; 292  :         virgin = 0;
; 293  :     }
; 294  : #else /* !BUILDFIXED */
; 295  : #   include "inffixed.h"
; 296  : #endif /* BUILDFIXED */
; 297  :     state->lencode = lenfix;

  00000	c7 41 4c 00 00
	00 00		 mov	 DWORD PTR [ecx+76], OFFSET ?lenfix@?1??fixedtables@@9@9

; 298  :     state->lenbits = 9;

  00007	c7 41 54 09 00
	00 00		 mov	 DWORD PTR [ecx+84], 9

; 299  :     state->distcode = distfix;

  0000e	c7 41 50 00 00
	00 00		 mov	 DWORD PTR [ecx+80], OFFSET ?distfix@?1??fixedtables@@9@9

; 300  :     state->distbits = 5;

  00015	c7 41 58 05 00
	00 00		 mov	 DWORD PTR [ecx+88], 5

; 301  : }

  0001c	c3		 ret	 0
_fixedtables ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\workspace\cocos2d-x-3.8.1\projects\mygame\libs\smartfox\zlib\inflate.c
;	COMDAT _updatewindow
_TEXT	SEGMENT
_strm$1$ = -4						; size = 4
_updatewindow PROC					; COMDAT
; _strm$ = ecx
; _out$ = edx

; 381  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	8b da		 mov	 ebx, edx
  00007	8b d1		 mov	 edx, ecx
  00009	56		 push	 esi
  0000a	57		 push	 edi
  0000b	89 55 fc	 mov	 DWORD PTR _strm$1$[ebp], edx

; 382  :     struct inflate_state FAR *state;
; 383  :     unsigned copy, dist;
; 384  : 
; 385  :     state = (struct inflate_state FAR *)strm->state;
; 386  : 
; 387  :     /* if it hasn't been done already, allocate space for the window */
; 388  :     if (state->window == Z_NULL) {

  0000e	bf 01 00 00 00	 mov	 edi, 1
  00013	8b 72 1c	 mov	 esi, DWORD PTR [edx+28]
  00016	83 7e 34 00	 cmp	 DWORD PTR [esi+52], 0
  0001a	75 27		 jne	 SHORT $LN9@updatewind

; 389  :         state->window = (unsigned char FAR *)
; 390  :                         ZALLOC(strm, 1U << state->wbits,
; 391  :                                sizeof(unsigned char));

  0001c	8b 4e 24	 mov	 ecx, DWORD PTR [esi+36]
  0001f	8b c7		 mov	 eax, edi
  00021	d3 e0		 shl	 eax, cl
  00023	57		 push	 edi
  00024	50		 push	 eax
  00025	ff 72 28	 push	 DWORD PTR [edx+40]
  00028	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  0002b	ff d0		 call	 eax
  0002d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00030	89 46 34	 mov	 DWORD PTR [esi+52], eax

; 392  :         if (state->window == Z_NULL) return 1;

  00033	85 c0		 test	 eax, eax
  00035	75 09		 jne	 SHORT $LN13@updatewind
  00037	8b c7		 mov	 eax, edi
  00039	5f		 pop	 edi
  0003a	5e		 pop	 esi
  0003b	5b		 pop	 ebx

; 426  : }

  0003c	8b e5		 mov	 esp, ebp
  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
$LN13@updatewind:
  00040	8b 55 fc	 mov	 edx, DWORD PTR _strm$1$[ebp]
$LN9@updatewind:

; 393  :     }
; 394  : 
; 395  :     /* if window not in use yet, initialize */
; 396  :     if (state->wsize == 0) {

  00043	83 7e 28 00	 cmp	 DWORD PTR [esi+40], 0
  00047	75 16		 jne	 SHORT $LN8@updatewind

; 397  :         state->wsize = 1U << state->wbits;

  00049	8b 4e 24	 mov	 ecx, DWORD PTR [esi+36]
  0004c	d3 e7		 shl	 edi, cl
  0004e	89 7e 28	 mov	 DWORD PTR [esi+40], edi

; 398  :         state->wnext = 0;

  00051	c7 46 30 00 00
	00 00		 mov	 DWORD PTR [esi+48], 0

; 399  :         state->whave = 0;

  00058	c7 46 2c 00 00
	00 00		 mov	 DWORD PTR [esi+44], 0
$LN8@updatewind:

; 400  :     }
; 401  : 
; 402  :     /* copy state->wsize or less output bytes into the circular window */
; 403  :     copy = out - strm->avail_out;

  0005f	2b 5a 10	 sub	 ebx, DWORD PTR [edx+16]

; 404  :     if (copy >= state->wsize) {

  00062	8b 7e 28	 mov	 edi, DWORD PTR [esi+40]

; 405  :         zmemcpy(state->window, strm->next_out - state->wsize, state->wsize);

  00065	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  00068	3b df		 cmp	 ebx, edi
  0006a	72 25		 jb	 SHORT $LN7@updatewind
  0006c	57		 push	 edi
  0006d	2b c7		 sub	 eax, edi
  0006f	50		 push	 eax
  00070	ff 76 34	 push	 DWORD PTR [esi+52]
  00073	e8 00 00 00 00	 call	 _memcpy

; 406  :         state->wnext = 0;
; 407  :         state->whave = state->wsize;

  00078	8b 46 28	 mov	 eax, DWORD PTR [esi+40]
  0007b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 422  :             if (state->whave < state->wsize) state->whave += dist;

  0007e	89 46 2c	 mov	 DWORD PTR [esi+44], eax

; 423  :         }
; 424  :     }
; 425  :     return 0;

  00081	33 c0		 xor	 eax, eax
  00083	c7 46 30 00 00
	00 00		 mov	 DWORD PTR [esi+48], 0
  0008a	5f		 pop	 edi
  0008b	5e		 pop	 esi
  0008c	5b		 pop	 ebx

; 426  : }

  0008d	8b e5		 mov	 esp, ebp
  0008f	5d		 pop	 ebp
  00090	c3		 ret	 0
$LN7@updatewind:

; 408  :     }
; 409  :     else {
; 410  :         dist = state->wsize - state->wnext;

  00091	2b 7e 30	 sub	 edi, DWORD PTR [esi+48]

; 411  :         if (dist > copy) dist = copy;

  00094	3b fb		 cmp	 edi, ebx
  00096	0f 47 fb	 cmova	 edi, ebx

; 412  :         zmemcpy(state->window + state->wnext, strm->next_out - copy, dist);

  00099	2b c3		 sub	 eax, ebx
  0009b	57		 push	 edi
  0009c	50		 push	 eax
  0009d	8b 46 34	 mov	 eax, DWORD PTR [esi+52]
  000a0	03 46 30	 add	 eax, DWORD PTR [esi+48]
  000a3	50		 push	 eax
  000a4	e8 00 00 00 00	 call	 _memcpy
  000a9	83 c4 0c	 add	 esp, 12			; 0000000cH

; 413  :         copy -= dist;

  000ac	2b df		 sub	 ebx, edi

; 414  :         if (copy) {

  000ae	74 27		 je	 SHORT $LN4@updatewind

; 415  :             zmemcpy(state->window, strm->next_out - copy, copy);

  000b0	8b 45 fc	 mov	 eax, DWORD PTR _strm$1$[ebp]
  000b3	53		 push	 ebx
  000b4	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  000b7	2b c3		 sub	 eax, ebx
  000b9	50		 push	 eax
  000ba	ff 76 34	 push	 DWORD PTR [esi+52]
  000bd	e8 00 00 00 00	 call	 _memcpy

; 416  :             state->wnext = copy;
; 417  :             state->whave = state->wsize;

  000c2	8b 46 28	 mov	 eax, DWORD PTR [esi+40]
  000c5	83 c4 0c	 add	 esp, 12			; 0000000cH
  000c8	89 5e 30	 mov	 DWORD PTR [esi+48], ebx

; 422  :             if (state->whave < state->wsize) state->whave += dist;

  000cb	89 46 2c	 mov	 DWORD PTR [esi+44], eax

; 423  :         }
; 424  :     }
; 425  :     return 0;

  000ce	33 c0		 xor	 eax, eax
  000d0	5f		 pop	 edi
  000d1	5e		 pop	 esi
  000d2	5b		 pop	 ebx

; 426  : }

  000d3	8b e5		 mov	 esp, ebp
  000d5	5d		 pop	 ebp
  000d6	c3		 ret	 0
$LN4@updatewind:

; 418  :         }
; 419  :         else {
; 420  :             state->wnext += dist;

  000d7	01 7e 30	 add	 DWORD PTR [esi+48], edi

; 421  :             if (state->wnext == state->wsize) state->wnext = 0;

  000da	8b 4e 28	 mov	 ecx, DWORD PTR [esi+40]
  000dd	39 4e 30	 cmp	 DWORD PTR [esi+48], ecx
  000e0	75 07		 jne	 SHORT $LN2@updatewind
  000e2	c7 46 30 00 00
	00 00		 mov	 DWORD PTR [esi+48], 0
$LN2@updatewind:

; 422  :             if (state->whave < state->wsize) state->whave += dist;

  000e9	8b 46 2c	 mov	 eax, DWORD PTR [esi+44]
  000ec	3b c1		 cmp	 eax, ecx
  000ee	73 05		 jae	 SHORT $LN1@updatewind
  000f0	03 c7		 add	 eax, edi
  000f2	89 46 2c	 mov	 DWORD PTR [esi+44], eax
$LN1@updatewind:

; 423  :         }
; 424  :     }
; 425  :     return 0;

  000f5	5f		 pop	 edi
  000f6	5e		 pop	 esi
  000f7	33 c0		 xor	 eax, eax
  000f9	5b		 pop	 ebx

; 426  : }

  000fa	8b e5		 mov	 esp, ebp
  000fc	5d		 pop	 ebp
  000fd	c3		 ret	 0
_updatewindow ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\workspace\cocos2d-x-3.8.1\projects\mygame\libs\smartfox\zlib\inflate.c
;	COMDAT _inflateSetDictionary@12
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_dictionary$ = 12					; size = 4
_dictLength$ = 16					; size = 4
_inflateSetDictionary@12 PROC				; COMDAT

; 1271 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1272 :     struct inflate_state FAR *state;
; 1273 :     unsigned long dictid;
; 1274 :     unsigned char *next;
; 1275 :     unsigned avail;
; 1276 :     int ret;
; 1277 : 
; 1278 :     /* check state */
; 1279 :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00006	53		 push	 ebx
  00007	85 c9		 test	 ecx, ecx
  00009	74 12		 je	 SHORT $LN5@inflateSet
  0000b	8b 59 1c	 mov	 ebx, DWORD PTR [ecx+28]
  0000e	85 db		 test	 ebx, ebx
  00010	74 0b		 je	 SHORT $LN5@inflateSet

; 1280 :     state = (struct inflate_state FAR *)strm->state;
; 1281 :     if (state->wrap != 0 && state->mode != DICT)

  00012	83 7b 08 00	 cmp	 DWORD PTR [ebx+8], 0
  00016	74 0f		 je	 SHORT $LN4@inflateSet
  00018	83 3b 0a	 cmp	 DWORD PTR [ebx], 10	; 0000000aH
  0001b	74 0f		 je	 SHORT $LN9@inflateSet
$LN5@inflateSet:

; 1272 :     struct inflate_state FAR *state;
; 1273 :     unsigned long dictid;
; 1274 :     unsigned char *next;
; 1275 :     unsigned avail;
; 1276 :     int ret;
; 1277 : 
; 1278 :     /* check state */
; 1279 :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  0001d	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  00022	5b		 pop	 ebx

; 1308 : }

  00023	5d		 pop	 ebp
  00024	c2 0c 00	 ret	 12			; 0000000cH
$LN4@inflateSet:

; 1282 :         return Z_STREAM_ERROR;
; 1283 : 
; 1284 :     /* check for correct dictionary identifier */
; 1285 :     if (state->mode == DICT) {

  00027	83 3b 0a	 cmp	 DWORD PTR [ebx], 10	; 0000000aH
  0002a	75 29		 jne	 SHORT $LN2@inflateSet
$LN9@inflateSet:

; 1286 :         dictid = adler32(0L, Z_NULL, 0);
; 1287 :         dictid = adler32(dictid, dictionary, dictLength);

  0002c	ff 75 10	 push	 DWORD PTR _dictLength$[ebp]
  0002f	ff 75 0c	 push	 DWORD PTR _dictionary$[ebp]
  00032	6a 00		 push	 0
  00034	6a 00		 push	 0
  00036	6a 00		 push	 0
  00038	e8 00 00 00 00	 call	 _adler32@12
  0003d	50		 push	 eax
  0003e	e8 00 00 00 00	 call	 _adler32@12

; 1288 :         if (dictid != state->check)

  00043	3b 43 18	 cmp	 eax, DWORD PTR [ebx+24]
  00046	74 0a		 je	 SHORT $LN10@inflateSet

; 1289 :             return Z_DATA_ERROR;

  00048	b8 fd ff ff ff	 mov	 eax, -3			; fffffffdH
  0004d	5b		 pop	 ebx

; 1308 : }

  0004e	5d		 pop	 ebp
  0004f	c2 0c 00	 ret	 12			; 0000000cH
$LN10@inflateSet:
  00052	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
$LN2@inflateSet:

; 1290 :     }
; 1291 : 
; 1292 :     /* copy dictionary to window using updatewindow(), which will amend the
; 1293 :        existing dictionary if appropriate */
; 1294 :     next = strm->next_out;
; 1295 :     avail = strm->avail_out;
; 1296 :     strm->next_out = (Bytef *)dictionary + dictLength;

  00055	8b 55 10	 mov	 edx, DWORD PTR _dictLength$[ebp]
  00058	8b 45 0c	 mov	 eax, DWORD PTR _dictionary$[ebp]
  0005b	56		 push	 esi
  0005c	8b 71 10	 mov	 esi, DWORD PTR [ecx+16]
  0005f	03 c2		 add	 eax, edx
  00061	57		 push	 edi
  00062	8b 79 0c	 mov	 edi, DWORD PTR [ecx+12]
  00065	89 41 0c	 mov	 DWORD PTR [ecx+12], eax

; 1297 :     strm->avail_out = 0;

  00068	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0

; 1298 :     ret = updatewindow(strm, dictLength);

  0006f	e8 00 00 00 00	 call	 _updatewindow

; 1299 :     strm->avail_out = avail;

  00074	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]

; 1300 :     strm->next_out = next;

  00077	89 79 0c	 mov	 DWORD PTR [ecx+12], edi
  0007a	89 71 10	 mov	 DWORD PTR [ecx+16], esi
  0007d	5f		 pop	 edi
  0007e	5e		 pop	 esi

; 1301 :     if (ret) {

  0007f	85 c0		 test	 eax, eax
  00081	74 10		 je	 SHORT $LN1@inflateSet

; 1302 :         state->mode = MEM;

  00083	c7 03 1e 00 00
	00		 mov	 DWORD PTR [ebx], 30	; 0000001eH

; 1303 :         return Z_MEM_ERROR;

  00089	b8 fc ff ff ff	 mov	 eax, -4			; fffffffcH
  0008e	5b		 pop	 ebx

; 1308 : }

  0008f	5d		 pop	 ebp
  00090	c2 0c 00	 ret	 12			; 0000000cH
$LN1@inflateSet:

; 1304 :     }
; 1305 :     state->havedict = 1;

  00093	c7 43 0c 01 00
	00 00		 mov	 DWORD PTR [ebx+12], 1

; 1306 :     Tracev((stderr, "inflate:   dictionary set\n"));
; 1307 :     return Z_OK;

  0009a	33 c0		 xor	 eax, eax
  0009c	5b		 pop	 ebx

; 1308 : }

  0009d	5d		 pop	 ebp
  0009e	c2 0c 00	 ret	 12			; 0000000cH
_inflateSetDictionary@12 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\workspace\cocos2d-x-3.8.1\projects\mygame\libs\smartfox\zlib\inflate.c
;	COMDAT _inflateGetHeader@8
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_head$ = 12						; size = 4
_inflateGetHeader@8 PROC				; COMDAT

; 1313 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1314 :     struct inflate_state FAR *state;
; 1315 : 
; 1316 :     /* check state */
; 1317 :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 20		 je	 SHORT $LN2@inflateGet
  0000a	8b 49 1c	 mov	 ecx, DWORD PTR [ecx+28]
  0000d	85 c9		 test	 ecx, ecx
  0000f	74 19		 je	 SHORT $LN2@inflateGet

; 1318 :     state = (struct inflate_state FAR *)strm->state;
; 1319 :     if ((state->wrap & 2) == 0) return Z_STREAM_ERROR;

  00011	f6 41 08 02	 test	 BYTE PTR [ecx+8], 2
  00015	74 13		 je	 SHORT $LN2@inflateGet

; 1320 : 
; 1321 :     /* save header structure */
; 1322 :     state->head = head;

  00017	8b 45 0c	 mov	 eax, DWORD PTR _head$[ebp]
  0001a	89 41 20	 mov	 DWORD PTR [ecx+32], eax

; 1323 :     head->done = 0;

  0001d	c7 40 30 00 00
	00 00		 mov	 DWORD PTR [eax+48], 0

; 1324 :     return Z_OK;

  00024	33 c0		 xor	 eax, eax

; 1325 : }

  00026	5d		 pop	 ebp
  00027	c2 08 00	 ret	 8
$LN2@inflateGet:

; 1314 :     struct inflate_state FAR *state;
; 1315 : 
; 1316 :     /* check state */
; 1317 :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  0002a	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH

; 1325 : }

  0002f	5d		 pop	 ebp
  00030	c2 08 00	 ret	 8
_inflateGetHeader@8 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\workspace\cocos2d-x-3.8.1\projects\mygame\libs\smartfox\zlib\inflate.c
;	COMDAT _syncsearch
_TEXT	SEGMENT
_buf$1$ = -8						; size = 4
_have$1$ = -4						; size = 4
_len$ = 8						; size = 4
_syncsearch PROC					; COMDAT
; _have$ = ecx
; _buf$ = edx

; 1342 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 1343 :     unsigned got;
; 1344 :     unsigned next;
; 1345 : 
; 1346 :     got = *have;

  00006	8b 01		 mov	 eax, DWORD PTR [ecx]
  00008	56		 push	 esi
  00009	57		 push	 edi

; 1347 :     next = 0;
; 1348 :     while (next < len && got < 4) {

  0000a	8b 7d 08	 mov	 edi, DWORD PTR _len$[ebp]
  0000d	33 f6		 xor	 esi, esi
  0000f	89 55 f8	 mov	 DWORD PTR _buf$1$[ebp], edx
  00012	89 4d fc	 mov	 DWORD PTR _have$1$[ebp], ecx
  00015	85 ff		 test	 edi, edi
  00017	74 51		 je	 SHORT $LN13@syncsearch
  00019	53		 push	 ebx
  0001a	8d 9b 00 00 00
	00		 npad	 6
$LL6@syncsearch:
  00020	83 f8 04	 cmp	 eax, 4
  00023	73 37		 jae	 SHORT $LN14@syncsearch

; 1349 :         if ((int)(buf[next]) == (got < 2 ? 0 : 0xff))

  00025	8a 1c 16	 mov	 bl, BYTE PTR [esi+edx]
  00028	83 f8 02	 cmp	 eax, 2
  0002b	0f b6 cb	 movzx	 ecx, bl
  0002e	1b d2		 sbb	 edx, edx
  00030	81 e2 01 ff ff
	ff		 and	 edx, -255		; ffffff01H
  00036	81 c2 ff 00 00
	00		 add	 edx, 255		; 000000ffH
  0003c	3b ca		 cmp	 ecx, edx
  0003e	75 03		 jne	 SHORT $LN4@syncsearch

; 1350 :             got++;

  00040	40		 inc	 eax
  00041	eb 11		 jmp	 SHORT $LN1@syncsearch
$LN4@syncsearch:

; 1351 :         else if (buf[next])

  00043	84 db		 test	 bl, bl
  00045	74 04		 je	 SHORT $LN2@syncsearch

; 1352 :             got = 0;

  00047	33 c0		 xor	 eax, eax

; 1353 :         else

  00049	eb 09		 jmp	 SHORT $LN1@syncsearch
$LN2@syncsearch:

; 1354 :             got = 4 - got;

  0004b	b9 04 00 00 00	 mov	 ecx, 4
  00050	2b c8		 sub	 ecx, eax
  00052	8b c1		 mov	 eax, ecx
$LN1@syncsearch:

; 1355 :         next++;

  00054	8b 55 f8	 mov	 edx, DWORD PTR _buf$1$[ebp]
  00057	46		 inc	 esi
  00058	3b f7		 cmp	 esi, edi
  0005a	72 c4		 jb	 SHORT $LL6@syncsearch
$LN14@syncsearch:

; 1356 :     }
; 1357 :     *have = got;

  0005c	8b 4d fc	 mov	 ecx, DWORD PTR _have$1$[ebp]
  0005f	5b		 pop	 ebx
  00060	5f		 pop	 edi
  00061	89 01		 mov	 DWORD PTR [ecx], eax

; 1358 :     return next;

  00063	8b c6		 mov	 eax, esi
  00065	5e		 pop	 esi

; 1359 : }

  00066	8b e5		 mov	 esp, ebp
  00068	5d		 pop	 ebp
  00069	c3		 ret	 0
$LN13@syncsearch:

; 1356 :     }
; 1357 :     *have = got;

  0006a	89 01		 mov	 DWORD PTR [ecx], eax

; 1358 :     return next;

  0006c	8b c6		 mov	 eax, esi
  0006e	5f		 pop	 edi
  0006f	5e		 pop	 esi

; 1359 : }

  00070	8b e5		 mov	 esp, ebp
  00072	5d		 pop	 ebp
  00073	c3		 ret	 0
_syncsearch ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\workspace\cocos2d-x-3.8.1\projects\mygame\libs\smartfox\zlib\inflate.c
;	COMDAT _inflateSync@4
_TEXT	SEGMENT
_in$1$ = 8						; size = 4
_buf$ = 8						; size = 4
_strm$ = 8						; size = 4
_inflateSync@4 PROC					; COMDAT

; 1363 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 1364 :     unsigned len;               /* number of bytes to look at or looked at */
; 1365 :     unsigned long in, out;      /* temporary to save total_in and total_out */
; 1366 :     unsigned char buf[4];       /* to restore bit buffer to byte string */
; 1367 :     struct inflate_state FAR *state;
; 1368 : 
; 1369 :     /* check parameters */
; 1370 :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  00004	8b 5d 08	 mov	 ebx, DWORD PTR _strm$[ebp]
  00007	57		 push	 edi
  00008	85 db		 test	 ebx, ebx
  0000a	0f 84 cf 00 00
	00		 je	 $LN6@inflateSyn
  00010	8b 7b 1c	 mov	 edi, DWORD PTR [ebx+28]
  00013	85 ff		 test	 edi, edi
  00015	0f 84 c4 00 00
	00		 je	 $LN6@inflateSyn

; 1371 :     state = (struct inflate_state FAR *)strm->state;
; 1372 :     if (strm->avail_in == 0 && state->bits < 8) return Z_BUF_ERROR;

  0001b	83 7b 04 00	 cmp	 DWORD PTR [ebx+4], 0
  0001f	75 11		 jne	 SHORT $LN5@inflateSyn
  00021	83 7f 3c 08	 cmp	 DWORD PTR [edi+60], 8
  00025	73 0b		 jae	 SHORT $LN5@inflateSyn
  00027	5f		 pop	 edi
  00028	b8 fb ff ff ff	 mov	 eax, -5			; fffffffbH
  0002d	5b		 pop	 ebx

; 1402 : }

  0002e	5d		 pop	 ebp
  0002f	c2 04 00	 ret	 4
$LN5@inflateSyn:

; 1373 : 
; 1374 :     /* if first time, start search in bit buffer */
; 1375 :     if (state->mode != SYNC) {

  00032	83 3f 1f	 cmp	 DWORD PTR [edi], 31	; 0000001fH
  00035	56		 push	 esi
  00036	74 56		 je	 SHORT $LN4@inflateSyn

; 1376 :         state->mode = SYNC;
; 1377 :         state->hold <<= state->bits & 7;

  00038	8b 57 3c	 mov	 edx, DWORD PTR [edi+60]

; 1378 :         state->bits -= state->bits & 7;
; 1379 :         len = 0;

  0003b	33 f6		 xor	 esi, esi
  0003d	8b ca		 mov	 ecx, edx
  0003f	c7 07 1f 00 00
	00		 mov	 DWORD PTR [edi], 31	; 0000001fH
  00045	83 e1 07	 and	 ecx, 7
  00048	d3 67 38	 shl	 DWORD PTR [edi+56], cl
  0004b	2b d1		 sub	 edx, ecx
  0004d	89 57 3c	 mov	 DWORD PTR [edi+60], edx

; 1380 :         while (state->bits >= 8) {

  00050	83 fa 08	 cmp	 edx, 8
  00053	72 24		 jb	 SHORT $LN2@inflateSyn
  00055	8b 4f 38	 mov	 ecx, DWORD PTR [edi+56]
  00058	eb 06 8d 9b 00
	00 00 00	 npad	 8
$LL3@inflateSyn:

; 1381 :             buf[len++] = (unsigned char)(state->hold);

  00060	8a 47 38	 mov	 al, BYTE PTR [edi+56]

; 1382 :             state->hold >>= 8;
; 1383 :             state->bits -= 8;

  00063	83 ea 08	 sub	 edx, 8
  00066	88 44 35 08	 mov	 BYTE PTR _buf$[ebp+esi], al
  0006a	46		 inc	 esi
  0006b	c1 e9 08	 shr	 ecx, 8
  0006e	89 4f 38	 mov	 DWORD PTR [edi+56], ecx
  00071	83 fa 08	 cmp	 edx, 8
  00074	73 ea		 jae	 SHORT $LL3@inflateSyn
  00076	89 57 3c	 mov	 DWORD PTR [edi+60], edx
$LN2@inflateSyn:

; 1384 :         }
; 1385 :         state->have = 0;

  00079	8d 4f 68	 lea	 ecx, DWORD PTR [edi+104]

; 1386 :         syncsearch(&(state->have), buf, len);

  0007c	8d 55 08	 lea	 edx, DWORD PTR _buf$[ebp]
  0007f	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
  00085	56		 push	 esi
  00086	e8 00 00 00 00	 call	 _syncsearch
  0008b	83 c4 04	 add	 esp, 4
$LN4@inflateSyn:

; 1387 :     }
; 1388 : 
; 1389 :     /* search available input */
; 1390 :     len = syncsearch(&(state->have), strm->next_in, strm->avail_in);

  0008e	ff 73 04	 push	 DWORD PTR [ebx+4]
  00091	8b 13		 mov	 edx, DWORD PTR [ebx]
  00093	8d 4f 68	 lea	 ecx, DWORD PTR [edi+104]
  00096	e8 00 00 00 00	 call	 _syncsearch

; 1391 :     strm->avail_in -= len;

  0009b	29 43 04	 sub	 DWORD PTR [ebx+4], eax
  0009e	83 c4 04	 add	 esp, 4

; 1392 :     strm->next_in += len;

  000a1	01 03		 add	 DWORD PTR [ebx], eax

; 1393 :     strm->total_in += len;

  000a3	01 43 08	 add	 DWORD PTR [ebx+8], eax

; 1394 : 
; 1395 :     /* return no joy or set up to restart inflate() on a new block */
; 1396 :     if (state->have != 4) return Z_DATA_ERROR;

  000a6	83 7f 68 04	 cmp	 DWORD PTR [edi+104], 4
  000aa	8b 43 08	 mov	 eax, DWORD PTR [ebx+8]
  000ad	89 45 08	 mov	 DWORD PTR _in$1$[ebp], eax
  000b0	74 0c		 je	 SHORT $LN1@inflateSyn
  000b2	5e		 pop	 esi
  000b3	5f		 pop	 edi
  000b4	b8 fd ff ff ff	 mov	 eax, -3			; fffffffdH
  000b9	5b		 pop	 ebx

; 1402 : }

  000ba	5d		 pop	 ebp
  000bb	c2 04 00	 ret	 4
$LN1@inflateSyn:

; 1397 :     in = strm->total_in;  out = strm->total_out;

  000be	8b 73 14	 mov	 esi, DWORD PTR [ebx+20]

; 1398 :     inflateReset(strm);

  000c1	53		 push	 ebx
  000c2	e8 00 00 00 00	 call	 _inflateReset@4

; 1399 :     strm->total_in = in;  strm->total_out = out;

  000c7	8b 45 08	 mov	 eax, DWORD PTR _in$1$[ebp]
  000ca	89 73 14	 mov	 DWORD PTR [ebx+20], esi
  000cd	89 43 08	 mov	 DWORD PTR [ebx+8], eax

; 1400 :     state->mode = TYPE;
; 1401 :     return Z_OK;

  000d0	33 c0		 xor	 eax, eax
  000d2	5e		 pop	 esi
  000d3	c7 07 0b 00 00
	00		 mov	 DWORD PTR [edi], 11	; 0000000bH
  000d9	5f		 pop	 edi
  000da	5b		 pop	 ebx

; 1402 : }

  000db	5d		 pop	 ebp
  000dc	c2 04 00	 ret	 4
$LN6@inflateSyn:
  000df	5f		 pop	 edi

; 1364 :     unsigned len;               /* number of bytes to look at or looked at */
; 1365 :     unsigned long in, out;      /* temporary to save total_in and total_out */
; 1366 :     unsigned char buf[4];       /* to restore bit buffer to byte string */
; 1367 :     struct inflate_state FAR *state;
; 1368 : 
; 1369 :     /* check parameters */
; 1370 :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  000e0	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  000e5	5b		 pop	 ebx

; 1402 : }

  000e6	5d		 pop	 ebp
  000e7	c2 04 00	 ret	 4
_inflateSync@4 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\workspace\cocos2d-x-3.8.1\projects\mygame\libs\smartfox\zlib\inflate.c
;	COMDAT _inflateSyncPoint@4
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_inflateSyncPoint@4 PROC				; COMDAT

; 1414 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1415 :     struct inflate_state FAR *state;
; 1416 : 
; 1417 :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  00003	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	74 21		 je	 SHORT $LN1@inflateSyn
  0000a	8b 40 1c	 mov	 eax, DWORD PTR [eax+28]
  0000d	85 c0		 test	 eax, eax
  0000f	74 1a		 je	 SHORT $LN1@inflateSyn

; 1418 :     state = (struct inflate_state FAR *)strm->state;
; 1419 :     return state->mode == STORED && state->bits == 0;

  00011	83 38 0d	 cmp	 DWORD PTR [eax], 13	; 0000000dH
  00014	75 0f		 jne	 SHORT $LN5@inflateSyn
  00016	83 78 3c 00	 cmp	 DWORD PTR [eax+60], 0
  0001a	75 09		 jne	 SHORT $LN5@inflateSyn
  0001c	b8 01 00 00 00	 mov	 eax, 1

; 1420 : }

  00021	5d		 pop	 ebp
  00022	c2 04 00	 ret	 4
$LN5@inflateSyn:

; 1418 :     state = (struct inflate_state FAR *)strm->state;
; 1419 :     return state->mode == STORED && state->bits == 0;

  00025	33 c0		 xor	 eax, eax

; 1420 : }

  00027	5d		 pop	 ebp
  00028	c2 04 00	 ret	 4
$LN1@inflateSyn:

; 1415 :     struct inflate_state FAR *state;
; 1416 : 
; 1417 :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  0002b	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH

; 1420 : }

  00030	5d		 pop	 ebp
  00031	c2 04 00	 ret	 4
_inflateSyncPoint@4 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\workspace\cocos2d-x-3.8.1\projects\mygame\libs\smartfox\zlib\inflate.c
;	COMDAT _inflateCopy@8
_TEXT	SEGMENT
_dest$ = 8						; size = 4
_window$1$ = 12						; size = 4
_source$ = 12						; size = 4
_inflateCopy@8 PROC					; COMDAT

; 1425 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1426 :     struct inflate_state FAR *state;
; 1427 :     struct inflate_state FAR *copy;
; 1428 :     unsigned char FAR *window;
; 1429 :     unsigned wsize;
; 1430 : 
; 1431 :     /* check input */
; 1432 :     if (dest == Z_NULL || source == Z_NULL || source->state == Z_NULL ||
; 1433 :         source->zalloc == (alloc_func)0 || source->zfree == (free_func)0)

  00003	8b 45 08	 mov	 eax, DWORD PTR _dest$[ebp]
  00006	56		 push	 esi
  00007	57		 push	 edi
  00008	85 c0		 test	 eax, eax
  0000a	0f 84 4a 01 00
	00		 je	 $LN6@inflateCop
  00010	8b 75 0c	 mov	 esi, DWORD PTR _source$[ebp]
  00013	85 f6		 test	 esi, esi
  00015	0f 84 3f 01 00
	00		 je	 $LN6@inflateCop
  0001b	8b 7e 1c	 mov	 edi, DWORD PTR [esi+28]
  0001e	85 ff		 test	 edi, edi
  00020	0f 84 34 01 00
	00		 je	 $LN6@inflateCop
  00026	8b 46 20	 mov	 eax, DWORD PTR [esi+32]
  00029	85 c0		 test	 eax, eax
  0002b	0f 84 29 01 00
	00		 je	 $LN6@inflateCop
  00031	83 7e 24 00	 cmp	 DWORD PTR [esi+36], 0
  00035	0f 84 1f 01 00
	00		 je	 $LN6@inflateCop

; 1435 :     state = (struct inflate_state FAR *)source->state;
; 1436 : 
; 1437 :     /* allocate space */
; 1438 :     copy = (struct inflate_state FAR *)
; 1439 :            ZALLOC(source, 1, sizeof(struct inflate_state));

  0003b	53		 push	 ebx
  0003c	68 cc 1b 00 00	 push	 7116			; 00001bccH
  00041	6a 01		 push	 1
  00043	ff 76 28	 push	 DWORD PTR [esi+40]
  00046	ff d0		 call	 eax
  00048	8b d8		 mov	 ebx, eax
  0004a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1440 :     if (copy == Z_NULL) return Z_MEM_ERROR;

  0004d	85 db		 test	 ebx, ebx
  0004f	74 38		 je	 SHORT $LN11@inflateCop

; 1441 :     window = Z_NULL;
; 1442 :     if (state->window != Z_NULL) {

  00051	83 7f 34 00	 cmp	 DWORD PTR [edi+52], 0
  00055	c7 45 0c 00 00
	00 00		 mov	 DWORD PTR _window$1$[ebp], 0
  0005c	74 37		 je	 SHORT $LN3@inflateCop

; 1443 :         window = (unsigned char FAR *)
; 1444 :                  ZALLOC(source, 1U << state->wbits, sizeof(unsigned char));

  0005e	8b 4f 24	 mov	 ecx, DWORD PTR [edi+36]
  00061	b8 01 00 00 00	 mov	 eax, 1
  00066	d3 e0		 shl	 eax, cl
  00068	6a 01		 push	 1
  0006a	50		 push	 eax
  0006b	ff 76 28	 push	 DWORD PTR [esi+40]
  0006e	8b 46 20	 mov	 eax, DWORD PTR [esi+32]
  00071	ff d0		 call	 eax
  00073	83 c4 0c	 add	 esp, 12			; 0000000cH
  00076	89 45 0c	 mov	 DWORD PTR _window$1$[ebp], eax

; 1445 :         if (window == Z_NULL) {

  00079	85 c0		 test	 eax, eax
  0007b	75 18		 jne	 SHORT $LN3@inflateCop

; 1446 :             ZFREE(source, copy);

  0007d	8b 46 24	 mov	 eax, DWORD PTR [esi+36]
  00080	53		 push	 ebx
  00081	ff 76 28	 push	 DWORD PTR [esi+40]
  00084	ff d0		 call	 eax
  00086	83 c4 08	 add	 esp, 8
$LN11@inflateCop:

; 1447 :             return Z_MEM_ERROR;

  00089	5b		 pop	 ebx
  0008a	5f		 pop	 edi
  0008b	b8 fc ff ff ff	 mov	 eax, -4			; fffffffcH
  00090	5e		 pop	 esi

; 1467 : }

  00091	5d		 pop	 ebp
  00092	c2 08 00	 ret	 8
$LN3@inflateCop:

; 1448 :         }
; 1449 :     }
; 1450 : 
; 1451 :     /* copy state */
; 1452 :     zmemcpy((voidpf)dest, (voidpf)source, sizeof(z_stream));

  00095	f3 0f 6f 06	 movdqu	 xmm0, XMMWORD PTR [esi]
  00099	8b 45 08	 mov	 eax, DWORD PTR _dest$[ebp]

; 1453 :     zmemcpy((voidpf)copy, (voidpf)state, sizeof(struct inflate_state));

  0009c	68 cc 1b 00 00	 push	 7116			; 00001bccH
  000a1	57		 push	 edi
  000a2	53		 push	 ebx
  000a3	f3 0f 7f 00	 movdqu	 XMMWORD PTR [eax], xmm0
  000a7	f3 0f 6f 46 10	 movdqu	 xmm0, XMMWORD PTR [esi+16]
  000ac	f3 0f 7f 40 10	 movdqu	 XMMWORD PTR [eax+16], xmm0
  000b1	f3 0f 6f 46 20	 movdqu	 xmm0, XMMWORD PTR [esi+32]
  000b6	f3 0f 7f 40 20	 movdqu	 XMMWORD PTR [eax+32], xmm0
  000bb	f3 0f 7e 46 30	 movq	 xmm0, QWORD PTR [esi+48]
  000c0	66 0f d6 40 30	 movq	 QWORD PTR [eax+48], xmm0
  000c5	e8 00 00 00 00	 call	 _memcpy

; 1454 :     if (state->lencode >= state->codes &&
; 1455 :         state->lencode <= state->codes + ENOUGH - 1) {

  000ca	8b 4f 4c	 mov	 ecx, DWORD PTR [edi+76]
  000cd	8d 87 30 05 00
	00		 lea	 eax, DWORD PTR [edi+1328]
  000d3	83 c4 0c	 add	 esp, 12			; 0000000cH
  000d6	3b c8		 cmp	 ecx, eax
  000d8	72 38		 jb	 SHORT $LN2@inflateCop
  000da	8d 87 bc 1b 00
	00		 lea	 eax, DWORD PTR [edi+7100]
  000e0	3b c8		 cmp	 ecx, eax
  000e2	77 2e		 ja	 SHORT $LN2@inflateCop

; 1456 :         copy->lencode = copy->codes + (state->lencode - state->codes);

  000e4	2b cf		 sub	 ecx, edi
  000e6	8d 81 d0 fa ff
	ff		 lea	 eax, DWORD PTR [ecx-1328]
  000ec	c1 f8 02	 sar	 eax, 2
  000ef	05 4c 01 00 00	 add	 eax, 332		; 0000014cH
  000f4	8d 04 83	 lea	 eax, DWORD PTR [ebx+eax*4]
  000f7	89 43 4c	 mov	 DWORD PTR [ebx+76], eax

; 1457 :         copy->distcode = copy->codes + (state->distcode - state->codes);

  000fa	8b 47 50	 mov	 eax, DWORD PTR [edi+80]
  000fd	2b c7		 sub	 eax, edi
  000ff	2d 30 05 00 00	 sub	 eax, 1328		; 00000530H
  00104	c1 f8 02	 sar	 eax, 2
  00107	05 4c 01 00 00	 add	 eax, 332		; 0000014cH
  0010c	8d 04 83	 lea	 eax, DWORD PTR [ebx+eax*4]
  0010f	89 43 50	 mov	 DWORD PTR [ebx+80], eax
$LN2@inflateCop:

; 1458 :     }
; 1459 :     copy->next = copy->codes + (state->next - state->codes);

  00112	8b 47 6c	 mov	 eax, DWORD PTR [edi+108]

; 1460 :     if (window != Z_NULL) {

  00115	8b 75 0c	 mov	 esi, DWORD PTR _window$1$[ebp]
  00118	2b c7		 sub	 eax, edi
  0011a	2d 30 05 00 00	 sub	 eax, 1328		; 00000530H
  0011f	c1 f8 02	 sar	 eax, 2
  00122	05 4c 01 00 00	 add	 eax, 332		; 0000014cH
  00127	8d 04 83	 lea	 eax, DWORD PTR [ebx+eax*4]
  0012a	89 43 6c	 mov	 DWORD PTR [ebx+108], eax
  0012d	85 f6		 test	 esi, esi
  0012f	74 17		 je	 SHORT $LN1@inflateCop

; 1461 :         wsize = 1U << state->wbits;

  00131	8b 4f 24	 mov	 ecx, DWORD PTR [edi+36]
  00134	b8 01 00 00 00	 mov	 eax, 1
  00139	d3 e0		 shl	 eax, cl

; 1462 :         zmemcpy(window, state->window, wsize);

  0013b	50		 push	 eax
  0013c	ff 77 34	 push	 DWORD PTR [edi+52]
  0013f	56		 push	 esi
  00140	e8 00 00 00 00	 call	 _memcpy
  00145	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@inflateCop:

; 1463 :     }
; 1464 :     copy->window = window;
; 1465 :     dest->state = (struct internal_state FAR *)copy;

  00148	8b 45 08	 mov	 eax, DWORD PTR _dest$[ebp]
  0014b	89 73 34	 mov	 DWORD PTR [ebx+52], esi
  0014e	89 58 1c	 mov	 DWORD PTR [eax+28], ebx

; 1466 :     return Z_OK;

  00151	33 c0		 xor	 eax, eax
  00153	5b		 pop	 ebx
  00154	5f		 pop	 edi
  00155	5e		 pop	 esi

; 1467 : }

  00156	5d		 pop	 ebp
  00157	c2 08 00	 ret	 8
$LN6@inflateCop:
  0015a	5f		 pop	 edi

; 1434 :         return Z_STREAM_ERROR;

  0015b	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  00160	5e		 pop	 esi

; 1467 : }

  00161	5d		 pop	 ebp
  00162	c2 08 00	 ret	 8
_inflateCopy@8 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\workspace\cocos2d-x-3.8.1\projects\mygame\libs\smartfox\zlib\inflate.c
;	COMDAT _inflateUndermine@8
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_subvert$ = 12						; size = 4
_inflateUndermine@8 PROC				; COMDAT

; 1472 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1473 :     struct inflate_state FAR *state;
; 1474 : 
; 1475 :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  00003	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	74 1a		 je	 SHORT $LN1@inflateUnd
  0000a	8b 40 1c	 mov	 eax, DWORD PTR [eax+28]
  0000d	85 c0		 test	 eax, eax
  0000f	74 13		 je	 SHORT $LN1@inflateUnd

; 1476 :     state = (struct inflate_state FAR *)strm->state;
; 1477 :     state->sane = !subvert;
; 1478 : #ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
; 1479 :     return Z_OK;
; 1480 : #else
; 1481 :     state->sane = 1;

  00011	c7 80 c0 1b 00
	00 01 00 00 00	 mov	 DWORD PTR [eax+7104], 1

; 1482 :     return Z_DATA_ERROR;

  0001b	b8 fd ff ff ff	 mov	 eax, -3			; fffffffdH

; 1483 : #endif
; 1484 : }

  00020	5d		 pop	 ebp
  00021	c2 08 00	 ret	 8
$LN1@inflateUnd:

; 1473 :     struct inflate_state FAR *state;
; 1474 : 
; 1475 :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  00024	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH

; 1483 : #endif
; 1484 : }

  00029	5d		 pop	 ebp
  0002a	c2 08 00	 ret	 8
_inflateUndermine@8 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\workspace\cocos2d-x-3.8.1\projects\mygame\libs\smartfox\zlib\inflate.c
;	COMDAT _inflateMark@4
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_inflateMark@4 PROC					; COMDAT

; 1488 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1489 :     struct inflate_state FAR *state;
; 1490 : 
; 1491 :     if (strm == Z_NULL || strm->state == Z_NULL) return -1L << 16;

  00003	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	74 4e		 je	 SHORT $LN1@inflateMar
  0000a	8b 40 1c	 mov	 eax, DWORD PTR [eax+28]
  0000d	85 c0		 test	 eax, eax
  0000f	74 47		 je	 SHORT $LN1@inflateMar

; 1492 :     state = (struct inflate_state FAR *)strm->state;
; 1493 :     return ((long)(state->back) << 16) +
; 1494 :         (state->mode == COPY ? state->length :
; 1495 :             (state->mode == MATCH ? state->was - state->length : 0));

  00011	8b 08		 mov	 ecx, DWORD PTR [eax]
  00013	83 f9 0f	 cmp	 ecx, 15			; 0000000fH
  00016	75 12		 jne	 SHORT $LN7@inflateMar
  00018	8b 48 40	 mov	 ecx, DWORD PTR [eax+64]
  0001b	8b 80 c4 1b 00
	00		 mov	 eax, DWORD PTR [eax+7108]
  00021	c1 e0 10	 shl	 eax, 16			; 00000010H
  00024	03 c1		 add	 eax, ecx

; 1496 : }

  00026	5d		 pop	 ebp
  00027	c2 04 00	 ret	 4
$LN7@inflateMar:

; 1492 :     state = (struct inflate_state FAR *)strm->state;
; 1493 :     return ((long)(state->back) << 16) +
; 1494 :         (state->mode == COPY ? state->length :
; 1495 :             (state->mode == MATCH ? state->was - state->length : 0));

  0002a	83 f9 18	 cmp	 ecx, 24			; 00000018H
  0002d	75 18		 jne	 SHORT $LN5@inflateMar
  0002f	8b 88 c8 1b 00
	00		 mov	 ecx, DWORD PTR [eax+7112]
  00035	2b 48 40	 sub	 ecx, DWORD PTR [eax+64]
  00038	8b 80 c4 1b 00
	00		 mov	 eax, DWORD PTR [eax+7108]
  0003e	c1 e0 10	 shl	 eax, 16			; 00000010H
  00041	03 c1		 add	 eax, ecx

; 1496 : }

  00043	5d		 pop	 ebp
  00044	c2 04 00	 ret	 4
$LN5@inflateMar:

; 1492 :     state = (struct inflate_state FAR *)strm->state;
; 1493 :     return ((long)(state->back) << 16) +
; 1494 :         (state->mode == COPY ? state->length :
; 1495 :             (state->mode == MATCH ? state->was - state->length : 0));

  00047	8b 80 c4 1b 00
	00		 mov	 eax, DWORD PTR [eax+7108]
  0004d	33 c9		 xor	 ecx, ecx
  0004f	c1 e0 10	 shl	 eax, 16			; 00000010H
  00052	03 c1		 add	 eax, ecx

; 1496 : }

  00054	5d		 pop	 ebp
  00055	c2 04 00	 ret	 4
$LN1@inflateMar:

; 1489 :     struct inflate_state FAR *state;
; 1490 : 
; 1491 :     if (strm == Z_NULL || strm->state == Z_NULL) return -1L << 16;

  00058	b8 00 00 ff ff	 mov	 eax, -65536		; ffff0000H

; 1496 : }

  0005d	5d		 pop	 ebp
  0005e	c2 04 00	 ret	 4
_inflateMark@4 ENDP
_TEXT	ENDS
END
